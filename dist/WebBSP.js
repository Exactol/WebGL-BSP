!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).WebBSP=t()}}(function(){var define,module,exports;return function(){return function t(n,e,a){function r(s,i){if(!e[s]){if(!n[s]){var u="function"==typeof require&&require;if(!i&&u)return u(s,!0);if(o)return o(s,!0);var m=new Error("Cannot find module '"+s+"'");throw m.code="MODULE_NOT_FOUND",m}var c=e[s]={exports:{}};n[s][0].call(c.exports,function(t){return r(n[s][1][t]||t)},c,c.exports,t,n,e,a)}return e[s].exports}for(var o="function"==typeof require&&require,s=0;s<a.length;s++)r(a[s]);return r}}()({"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\BSP.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Utils/BinaryReader"),r=t("./Lumps/LumpType"),o=t("./Lumps/LumpHeader"),s=t("./Lumps/EdgeLump"),i=t("./Lumps/GenericLump"),u=t("./Lumps/VertexLump"),m=t("./Lumps/PlaneLump"),c=t("./Lumps/SurfEdgeLump"),l=t("./Lumps/FaceLump"),p=t("./Lumps/OriginalFaceLump"),d=t("./Lumps/BrushLump"),b=t("./Lumps/BrushSideLump"),h=t("./Lumps/NodeLump"),v=t("./Lumps/LeafLump"),f=t("./Lumps/LeafFaceLump"),x=t("./Lumps/LeafBrushLump"),g=t("./Lumps/TexInfoLump"),y=t("./Lumps/TexDataLump"),L=t("./Lumps/TexDataStringTableLump"),S=t("./Lumps/TexDataStringDataLump"),P=t("./Lumps/ModelLump"),w=t("./Lumps/EntityLump"),z=t("./Lumps/GameLump"),q=t("./Lumps/CubemapLump"),M=t("./Lumps/LightingLump"),j=t("./Lumps/LeafAmbientLightingLump"),D=t("./Lumps/LeafAmbientIndexLump"),T=t("./Lumps/LeafAmbientIndexHDRLump"),B=t("./Lumps/DispInfoLump"),_=t("./Lumps/DispVertLump"),O=t("./Lumps/DispTrisLump");e.BSP=class{constructor(t){this.headerLumps=[],this.lumps={},this.fileData=t,this.reader=new a.BinaryReader(this.fileData),console.log("--Header--"),this.ident="";for(let t=0;t<4;t++)this.ident+=this.reader.readChar();console.log("Ident: "+this.ident),this.version=this.reader.readInt32(),console.log("Version: "+this.version),console.log("--Reading Header Lumps--");for(let t=0;t<64;t++){const n=this.getLumpType(t);this.lumps[t]=new n(new o.LumpHeader(t,this.reader.readBytes(16)),this.fileData)}}readLump(t){if(this.lumps[t].initialized)return this.lumps[t];const n=this.lumps[t];return n.read(),n}printLumps(){for(const t in this.lumps)if(this.lumps.hasOwnProperty(t)){const n=this.lumps[t];n.initialized?console.log(n.toString()):(this.readLump(Number.parseInt(t)),console.log(n))}}getLumpType(t){switch(t){case r.LumpType.Entities:return w.EntityLump;case r.LumpType.Planes:return m.PlaneLump;case r.LumpType.TexData:return y.TexDataLump;case r.LumpType.Vertexes:return u.VertexLump;case r.LumpType.Nodes:return h.NodeLump;case r.LumpType.TexInfo:return g.TexInfoLump;case r.LumpType.Faces:return l.FaceLump;case r.LumpType.Lighting:return M.LightingLump;case r.LumpType.Leafs:return v.LeafLump;case r.LumpType.Edges:return s.EdgeLump;case r.LumpType.SurfEdges:return c.SurfEdgeLump;case r.LumpType.Models:return P.ModelLump;case r.LumpType.LeafFaces:return f.LeafFaceLump;case r.LumpType.LeafBrushes:return x.LeafBrushLump;case r.LumpType.Brushes:return d.BrushLump;case r.LumpType.BrushSides:return b.BrushSideLump;case r.LumpType.DispInfo:return B.DispInfoLump;case r.LumpType.OriginalFaces:return p.OriginalFaceLump;case r.LumpType.DispVerts:return _.DispVertLump;case r.LumpType.Game:return z.GameLump;case r.LumpType.Cubemaps:return q.CubemapLump;case r.LumpType.TexDataStringData:return S.TexDataStringDataLump;case r.LumpType.TexDataStringTable:return L.TexDataStringTableLump;case r.LumpType.DispTris:return O.DispTrisLump;case r.LumpType.LeafAmbientIndexHdr:return T.LeafAmbientIndexHdrLump;case r.LumpType.LeafAmbientIndex:return D.LeafAmbientIndexLump;case r.LumpType.LeafAmbientLighting:return j.LeafAmbientLightingLump;default:return i.GenericLump}}}},{"./Lumps/BrushLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\BrushLump.js","./Lumps/BrushSideLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\BrushSideLump.js","./Lumps/CubemapLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\CubemapLump.js","./Lumps/DispInfoLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\DispInfoLump.js","./Lumps/DispTrisLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\DispTrisLump.js","./Lumps/DispVertLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\DispVertLump.js","./Lumps/EdgeLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\EdgeLump.js","./Lumps/EntityLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\EntityLump.js","./Lumps/FaceLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\FaceLump.js","./Lumps/GameLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\GameLump.js","./Lumps/GenericLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\GenericLump.js","./Lumps/LeafAmbientIndexHDRLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LeafAmbientIndexHDRLump.js","./Lumps/LeafAmbientIndexLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LeafAmbientIndexLump.js","./Lumps/LeafAmbientLightingLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LeafAmbientLightingLump.js","./Lumps/LeafBrushLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LeafBrushLump.js","./Lumps/LeafFaceLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LeafFaceLump.js","./Lumps/LeafLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LeafLump.js","./Lumps/LightingLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LightingLump.js","./Lumps/LumpHeader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpHeader.js","./Lumps/LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js","./Lumps/ModelLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\ModelLump.js","./Lumps/NodeLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\NodeLump.js","./Lumps/OriginalFaceLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\OriginalFaceLump.js","./Lumps/PlaneLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\PlaneLump.js","./Lumps/SurfEdgeLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\SurfEdgeLump.js","./Lumps/TexDataLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\TexDataLump.js","./Lumps/TexDataStringDataLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\TexDataStringDataLump.js","./Lumps/TexDataStringTableLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\TexDataStringTableLump.js","./Lumps/TexInfoLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\TexInfoLump.js","./Lumps/VertexLump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\VertexLump.js","./Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\BrushLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader"),s=t("../Structs/Brush");e.BrushLump=class extends a.Lump{constructor(t,n){super(r.LumpType.Brushes,t,n),this.brushes=[]}read(){const t=new o.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=3*o.INT_32_SIZE)this.brushes.push(new s.Brush(t.readInt32(),t.readInt32(),t.readInt32()));this.initialized=!0}toString(){let t=super.toString();return t+=`\n${r.LumpType[this.lumpType]}: \n${this.brushes.join("\n")}`}}},{"../Structs/Brush":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\Brush.js","../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\BrushSideLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader"),s=t("../Structs/BrushSide");e.BrushSideLump=class extends a.Lump{constructor(t,n){super(r.LumpType.BrushSides,t,n),this.brushes=[]}read(){const t=new o.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=3*o.INT_16_SIZE+o.UINT_16_SIZE)this.brushes.push(new s.BrushSide(t.readUInt16(),t.readInt16(),t.readInt16(),t.readInt16()));this.initialized=!0}toString(){let t=super.toString();return t+=`\n${r.LumpType[this.lumpType]}: \n${this.brushes.join("\n")}`}}},{"../Structs/BrushSide":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\BrushSide.js","../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\CubemapLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader"),s=t("../Structs/Cubemap");e.CubemapLump=class extends a.Lump{constructor(t,n){super(r.LumpType.Cubemaps,t,n),this.cubemaps=[]}read(){const t=new o.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=16)this.cubemaps.push(new s.Cubemap([t.readInt32(),t.readInt32(),t.readInt32()],t.readInt32()));this.initialized=!0}toString(){let t=super.toString();return t+=`\n${r.LumpType[this.lumpType]}: \n${this.cubemaps.join("\n")}`}}},{"../Structs/Cubemap":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\Cubemap.js","../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\DispInfoLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader"),s=t("../Structs/DispInfo"),i=t("gl-matrix"),u=t("../Structs/DispNeighbor"),m=t("../Structs/DispSubNeighbor"),c=t("../Structs/DispCornerNeighbor");e.DispInfoLump=class extends a.Lump{constructor(t,n){super(r.LumpType.DispInfo,t,n),this.dispInfos=[]}read(){const t=new o.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=176){const n=i.vec3.fromValues(t.readFloat(),t.readFloat(),t.readFloat()),e=t.readInt32(),a=t.readInt32(),r=t.readInt32(),l=t.readInt32(),p=t.readFloat(),d=t.readInt32(),b=t.readUInt16(),h=t.readInt32(),v=t.readInt32(),f=[];for(let n=0;n<4;n++){const n=[];for(let e=0;e<2;e++){const e=t.readUInt16(),a=t.readUInt8(),r=t.readUInt8();t.seek(1,o.SeekOrigin.Current);const s=t.readUInt8();n.push(new m.DispSubNeighbor(e,a,r,s))}f.push(new u.DispNeighbor(n))}const x=[];for(let n=0;n<4;n++)x.push(new c.DispCornerNeighbors([t.readUInt16(),t.readUInt16(),t.readUInt16(),t.readUInt16()],t.readUInt8()));t.seek(6,o.SeekOrigin.Current);const g=[];for(let n=0;n<10;n++)g.push(t.readUInt32());this.dispInfos.push(new s.DispInfo(n,e,a,r,l,p,d,b,h,v,f,x,g))}this.initialized=!0}toString(){let t=super.toString();return t+=`\n${r.LumpType[this.lumpType]}: \n${this.dispInfos.join("\n")}`}}},{"../Structs/DispCornerNeighbor":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\DispCornerNeighbor.js","../Structs/DispInfo":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\DispInfo.js","../Structs/DispNeighbor":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\DispNeighbor.js","../Structs/DispSubNeighbor":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\DispSubNeighbor.js","../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js","gl-matrix":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\node_modules\\gl-matrix\\dist\\gl-matrix.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\DispTrisLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("../Utils/BinaryReader"),o=t("./LumpType");e.DispTrisLump=class extends a.Lump{constructor(t,n){super(o.LumpType.DispTris,t,n),this.dispTris=[]}read(){const t=new r.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=r.UINT_16_SIZE)this.dispTris.push(t.readUInt16());this.initialized=!0}toString(){let t=super.toString();return t+=`\n${o.LumpType[this.lumpType]}: [${this.dispTris.join(", ")}]`}}},{"../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\DispVertLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("../Utils/BinaryReader"),o=t("./LumpType"),s=t("../Structs/DispVert"),i=t("gl-matrix");e.DispVertLump=class extends a.Lump{constructor(t,n){super(o.LumpType.DispVerts,t,n),this.dispVerts=[]}read(){const t=new r.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=5*r.FLOAT_SIZE)this.dispVerts.push(new s.DispVert(i.vec3.fromValues(t.readFloat(),t.readFloat(),t.readFloat()),t.readFloat(),t.readFloat()));this.initialized=!0}toString(){let t=super.toString();return t+=`\n${o.LumpType[this.lumpType]}: ${this.dispVerts.join("\n")}`}}},{"../Structs/DispVert":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\DispVert.js","../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js","gl-matrix":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\node_modules\\gl-matrix\\dist\\gl-matrix.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\EdgeLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("../Structs/Edge"),o=t("../Utils/BinaryReader"),s=t("./LumpType");e.EdgeLump=class extends a.Lump{constructor(t,n){super(s.LumpType.Edges,t,n),this.edges=[]}read(){const t=new o.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=2*o.UINT_16_SIZE)this.edges.push(new r.Edge(t.readUInt16(),t.readUInt16()));this.initialized=!0}toString(){let t=super.toString();return t+=`\n${s.LumpType[this.lumpType]}: [${this.edges.join(", ")}]`}}},{"../Structs/Edge":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\Edge.js","../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\EntityLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader");e.EntityLump=class extends a.Lump{constructor(t,n){super(r.LumpType.Entities,t,n),this.textBuffer=""}read(){const t=new o.BinaryReader(this.data);let n=t.readString(!1);for(;null!=n;)this.textBuffer+=n,n=t.readString(!1);this.initialized=!0}toString(){let t=super.toString();return t+=`\nTextBuffer: \n${this.textBuffer}`}}},{"../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\FaceLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader"),s=t("../Structs/Face");e.FaceLump=class extends a.Lump{constructor(t,n){super(r.LumpType.Faces,t,n),this.faces=[]}read(){const t=new o.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=56)this.faces.push(new s.Face(t.readInt16(),t.readInt8(),t.readInt8(),t.readInt32(),t.readInt16(),t.readInt16(),t.readInt16(),t.readInt16(),t.readBytes(4),t.readInt32(),t.readFloat(),[t.readInt32(),t.readInt32()],[t.readInt32(),t.readInt32()],t.readInt32(),t.readUInt16(),t.readUInt16(),t.readUInt32()));this.initialized=!0}toString(){let t=super.toString();return t+=`\n${r.LumpType[this.lumpType]}: \n${this.faces.join("\n")}`}}},{"../Structs/Face":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\Face.js","../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\GameLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader"),s=t("../Structs/GameLumpStruct");e.GameLump=class extends a.Lump{constructor(t,n){super(r.LumpType.Game,t,n),this.lumpCount=0,this.lumps=[]}read(){const t=new o.BinaryReader(this.data);this.lumpCount=t.readInt32();for(let n=0;n<this.lumpCount;n++)this.lumps.push(new s.GameLumpStruct(t.readInt32(),t.readUInt16(),t.readUInt16(),t.readInt32(),t.readInt32()));this.initialized=!0}toString(){let t=super.toString();return t+=`\nLump Count: ${this.lumpCount}\n\t\t${r.LumpType[this.lumpType]}: \n${this.lumps.join("\n")}`}}},{"../Structs/GameLumpStruct":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\GameLumpStruct.js","../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\GenericLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType");e.GenericLump=class extends a.Lump{constructor(t,n){super(r.LumpType.Generic,t,n)}}},{"./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LeafAmbientIndexHDRLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader"),s=t("../Structs/LeafAmbientIndex");e.LeafAmbientIndexHdrLump=class extends a.Lump{constructor(t,n){super(r.LumpType.LeafAmbientIndexHdr,t,n),this.leafAmbientIndex=[]}read(){const t=new o.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=2*o.UINT_16_SIZE)this.leafAmbientIndex.push(new s.LeafAmbientIndex(t.readUInt16(),t.readUInt16()));this.initialized=!0}toString(){let t=super.toString();return t+=`\n${r.LumpType[this.lumpType]}: \n${this.leafAmbientIndex.join("\n\n")}`}}},{"../Structs/LeafAmbientIndex":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\LeafAmbientIndex.js","../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LeafAmbientIndexLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader"),s=t("../Structs/LeafAmbientIndex");e.LeafAmbientIndexLump=class extends a.Lump{constructor(t,n){super(r.LumpType.LeafAmbientIndex,t,n),this.leafAmbientIndex=[]}read(){const t=new o.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=2*o.UINT_16_SIZE)this.leafAmbientIndex.push(new s.LeafAmbientIndex(t.readUInt16(),t.readUInt16()));this.initialized=!0}toString(){let t=super.toString();return t+=`\n${r.LumpType[this.lumpType]}: \n${this.leafAmbientIndex.join("\n\n")}`}}},{"../Structs/LeafAmbientIndex":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\LeafAmbientIndex.js","../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LeafAmbientLightingLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader"),s=t("../Structs/ColorRGBExp32"),i=t("../Structs/LeafAmbientLighting"),u=t("../Structs/CompressedLightCube");e.LeafAmbientLightingLump=class extends a.Lump{constructor(t,n){super(r.LumpType.LeafAmbientLighting,t,n),this.leafAmbientLighting=[]}read(){const t=new o.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=28)this.leafAmbientLighting.push(new i.LeafAmbientLighting(new u.CompressedLightCube([new s.ColorRGBExp32(t.readUInt8(),t.readUInt8(),t.readUInt8(),t.readInt8()),new s.ColorRGBExp32(t.readUInt8(),t.readUInt8(),t.readUInt8(),t.readInt8()),new s.ColorRGBExp32(t.readUInt8(),t.readUInt8(),t.readUInt8(),t.readInt8()),new s.ColorRGBExp32(t.readUInt8(),t.readUInt8(),t.readUInt8(),t.readInt8()),new s.ColorRGBExp32(t.readUInt8(),t.readUInt8(),t.readUInt8(),t.readInt8()),new s.ColorRGBExp32(t.readUInt8(),t.readUInt8(),t.readUInt8(),t.readInt8())]),t.readUInt8(),t.readUInt8(),t.readUInt8(),t.readUInt8()));this.initialized=!0}toString(){let t=super.toString();return t+=`\n${r.LumpType[this.lumpType]}: \n${this.leafAmbientLighting.join("\n")}`}}},{"../Structs/ColorRGBExp32":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\ColorRGBExp32.js","../Structs/CompressedLightCube":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\CompressedLightCube.js","../Structs/LeafAmbientLighting":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\LeafAmbientLighting.js","../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LeafBrushLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader");e.LeafBrushLump=class extends a.Lump{constructor(t,n){super(r.LumpType.LeafBrushes,t,n),this.leafBrushes=[]}read(){const t=new o.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=o.UINT_16_SIZE)this.leafBrushes.push(t.readUInt16());this.initialized=!0}toString(){let t=super.toString();return t+=`\n${r.LumpType[this.lumpType]}: [${this.leafBrushes.join(", ")}]`}}},{"../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LeafFaceLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader");e.LeafFaceLump=class extends a.Lump{constructor(t,n){super(r.LumpType.LeafFaces,t,n),this.leafFaces=[]}read(){const t=new o.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=o.UINT_16_SIZE)this.leafFaces.push(t.readUInt16());this.initialized=!0}toString(){let t=super.toString();return t+=`\n${r.LumpType[this.lumpType]}: [${this.leafFaces.join(", ")}]`}}},{"../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LeafLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader"),s=t("../Structs/Leaf");e.LeafLump=class extends a.Lump{constructor(t,n){super(r.LumpType.Leafs,t,n),this.leaves=[]}read(){const t=new o.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=56)this.leaves.push(new s.Leaf(t.readInt32(),t.readInt16(),511&t.readInt16(),127&t.readInt16(),[t.readInt16(),t.readInt16(),t.readInt16()],[t.readInt16(),t.readInt16(),t.readInt16()],t.readUInt16(),t.readUInt16(),t.readUInt16(),t.readUInt16(),t.readInt16()));this.initialized=!0}toString(){let t=super.toString();return t+=`\n${r.LumpType[this.lumpType]}: \n${this.leaves.join("\n")}`}}},{"../Structs/Leaf":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\Leaf.js","../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LightingLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader"),s=t("../Structs/ColorRGBExp32");e.LightingLump=class extends a.Lump{constructor(t,n){super(r.LumpType.Lighting,t,n),this.lightmapSamples=[]}read(){const t=new o.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=4)this.lightmapSamples.push(new s.ColorRGBExp32(t.readUInt8(),t.readUInt8(),t.readUInt8(),t.readInt8()));this.initialized=!0}toString(){let t=super.toString();return t+=`\n${r.LumpType[this.lumpType]}: \n${this.lightmapSamples.join("\n")}`}}},{"../Structs/ColorRGBExp32":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\ColorRGBExp32.js","../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./LumpType"),r=t("../Utils/BinaryReader"),o=1095588428;e.Lump=class{constructor(t,n,e){this.initialized=!1,this.lumpDependencies=[],this.lumpType=t,this.header=n,this.data=e.slice(this.header.fileOffset,this.header.fileOffset+this.header.lumpLength);let a=!1;for(let t=0;t<this.header.fourCC.length;t++)if(0!==this.header.fourCC[t]){a=!0;break}a&&this.decompressLump()}read(){}decompressLump(){const t=new r.BinaryReader(this.data);if(t.readInt32()!==o)return;t.readInt32(),t.readInt32();const n=[];for(let e=0;e<5;e++)n.push(t.readUInt8());throw Error("Decompressing lumps is not implemented.")}toString(){return`${a.LumpType[this.lumpType]}\n\t\t${this.header} \n\t\tLump:\n\t\t\tData: ${this.data}\n\t\t\tInitialized: ${this.initialized}`}}},{"../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpHeader.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("../Utils/BinaryReader");e.LumpHeader=class{constructor(t,n){const e=new a.BinaryReader(n.buffer,n.byteOffset);this.fileOffset=e.readInt32(),this.lumpLength=e.readInt32(),this.version=e.readInt32(),this.fourCC=e.readBytes(4)}toString(){return`Offset: ${this.fileOffset}\n\t\t\tLength: ${this.lumpLength} \n\t\t\tVersion: ${this.version}\n\t\t\tFourCC: ${this.fourCC}`}}},{"../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),function(t){t[t.Entities=0]="Entities",t[t.Planes=1]="Planes",t[t.TexData=2]="TexData",t[t.Vertexes=3]="Vertexes",t[t.Visibility=4]="Visibility",t[t.Nodes=5]="Nodes",t[t.TexInfo=6]="TexInfo",t[t.Faces=7]="Faces",t[t.Lighting=8]="Lighting",t[t.Occlusion=9]="Occlusion",t[t.Leafs=10]="Leafs",t[t.FaceIds=11]="FaceIds",t[t.Edges=12]="Edges",t[t.SurfEdges=13]="SurfEdges",t[t.Models=14]="Models",t[t.WorldLights=15]="WorldLights",t[t.LeafFaces=16]="LeafFaces",t[t.LeafBrushes=17]="LeafBrushes",t[t.Brushes=18]="Brushes",t[t.BrushSides=19]="BrushSides",t[t.Areas=20]="Areas",t[t.AreaPortals=21]="AreaPortals",t[t.Portals=22]="Portals",t[t.Unused0=22]="Unused0",t[t.PropCollsion=22]="PropCollsion",t[t.Clusters=23]="Clusters",t[t.Unused1=23]="Unused1",t[t.PropHulls=23]="PropHulls",t[t.PortalVerts=24]="PortalVerts",t[t.Unused2=24]="Unused2",t[t.PropHullVerts=24]="PropHullVerts",t[t.ClusterPortals=25]="ClusterPortals",t[t.Unused3=25]="Unused3",t[t.PropTris=25]="PropTris",t[t.DispInfo=26]="DispInfo",t[t.OriginalFaces=27]="OriginalFaces",t[t.PhysDisp=28]="PhysDisp",t[t.PhysCollide=29]="PhysCollide",t[t.VertNormals=30]="VertNormals",t[t.VertNormalIndices=31]="VertNormalIndices",t[t.DispLightmapAlphas=32]="DispLightmapAlphas",t[t.DispVerts=33]="DispVerts",t[t.DispLightmapSamplePositions=34]="DispLightmapSamplePositions",t[t.Game=35]="Game",t[t.LeafWaterData=36]="LeafWaterData",t[t.Primitives=37]="Primitives",t[t.PrimVerts=38]="PrimVerts",t[t.PrimIndices=39]="PrimIndices",t[t.Pakfile=40]="Pakfile",t[t.ClipPortalVerts=41]="ClipPortalVerts",t[t.Cubemaps=42]="Cubemaps",t[t.TexDataStringData=43]="TexDataStringData",t[t.TexDataStringTable=44]="TexDataStringTable",t[t.Overlays=45]="Overlays",t[t.LeafMinDistToWater=46]="LeafMinDistToWater",t[t.FaceMacroTextureInfo=47]="FaceMacroTextureInfo",t[t.DispTris=48]="DispTris",t[t.PhysCollideSurface=49]="PhysCollideSurface",t[t.PropBlob=49]="PropBlob",t[t.WaterOverlays=50]="WaterOverlays",t[t.LightmapPages=51]="LightmapPages",t[t.LeafAmbientIndexHdr=51]="LeafAmbientIndexHdr",t[t.LightmapPageInfos=52]="LightmapPageInfos",t[t.LeafAmbientIndex=52]="LeafAmbientIndex",t[t.LightingHdr=53]="LightingHdr",t[t.WorldLightsHdr=54]="WorldLightsHdr",t[t.LeafAmbientLightingHdr=55]="LeafAmbientLightingHdr",t[t.LeafAmbientLighting=56]="LeafAmbientLighting",t[t.XZipPackfile=57]="XZipPackfile",t[t.FacesHdr=58]="FacesHdr",t[t.MapFlags=59]="MapFlags",t[t.OverlayFades=60]="OverlayFades",t[t.OverlaySystemLevels=61]="OverlaySystemLevels",t[t.PhysLevel=62]="PhysLevel",t[t.DispMultiBlend=63]="DispMultiBlend",t[t.Generic=-1]="Generic"}(e.LumpType||(e.LumpType={}))},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\ModelLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader"),s=t("../Structs/Model"),i=t("gl-matrix");e.ModelLump=class extends a.Lump{constructor(t,n){super(r.LumpType.Models,t,n),this.models=[]}read(){const t=new o.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=48)this.models.push(new s.Model(i.vec3.fromValues(t.readFloat(),t.readFloat(),t.readFloat()),i.vec3.fromValues(t.readFloat(),t.readFloat(),t.readFloat()),i.vec3.fromValues(t.readFloat(),t.readFloat(),t.readFloat()),t.readInt32(),t.readInt32(),t.readInt32()));this.initialized=!0}toString(){let t=super.toString();return t+=`\n${r.LumpType[this.lumpType]}: \n${this.models.join("\n")}`}}},{"../Structs/Model":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\Model.js","../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js","gl-matrix":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\node_modules\\gl-matrix\\dist\\gl-matrix.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\NodeLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader"),s=t("../Structs/Node");e.NodeLump=class extends a.Lump{constructor(t,n){super(r.LumpType.Nodes,t,n),this.nodes=[]}read(){const t=new o.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=32)this.nodes.push(new s.Node(t.readInt32(),[t.readInt32(),t.readInt32()],[t.readInt16(),t.readInt16(),t.readInt16()],[t.readInt16(),t.readInt16(),t.readInt16()],t.readUInt16(),t.readUInt16(),t.readInt16(),t.readInt16()));this.initialized=!0}toString(){let t=super.toString();return t+=`\n${r.LumpType[this.lumpType]}: \n${this.nodes.join("\n")}`}}},{"../Structs/Node":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\Node.js","../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\OriginalFaceLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader"),s=t("../Structs/Face");e.OriginalFaceLump=class extends a.Lump{constructor(t,n){super(r.LumpType.OriginalFaces,t,n),this.faces=[]}read(){const t=new o.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=56)this.faces.push(new s.Face(t.readInt16(),t.readInt8(),t.readInt8(),t.readInt32(),t.readInt16(),t.readInt16(),t.readInt16(),t.readInt16(),t.readBytes(4),t.readInt32(),t.readFloat(),[t.readInt32(),t.readInt32()],[t.readInt32(),t.readInt32()],t.readInt32(),t.readUInt16(),t.readUInt16(),t.readUInt32()));this.initialized=!0}toString(){let t=super.toString();return t+=`\n${r.LumpType[this.lumpType]}: \n${this.faces.join("\n")}`}}},{"../Structs/Face":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\Face.js","../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\PlaneLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("../Structs/Plane"),o=t("./LumpType"),s=t("../Utils/BinaryReader"),i=t("gl-matrix");e.PlaneLump=class extends a.Lump{constructor(t,n){super(o.LumpType.Planes,t,n),this.planes=[]}read(){const t=new s.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=4*s.FLOAT_SIZE+s.INT_32_SIZE)this.planes.push(new r.Plane(i.vec3.fromValues(t.readFloat(),t.readFloat(),t.readFloat()),t.readFloat(),t.readInt32()));this.initialized=!0}toString(){let t=super.toString();return t+=`\n${o.LumpType[this.lumpType]}: \n${this.planes.join("\n")}`}}},{"../Structs/Plane":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\Plane.js","../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js","gl-matrix":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\node_modules\\gl-matrix\\dist\\gl-matrix.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\SurfEdgeLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader");e.SurfEdgeLump=class extends a.Lump{constructor(t,n){super(r.LumpType.SurfEdges,t,n),this.surfEdges=[]}read(){const t=new o.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=o.INT_32_SIZE)this.surfEdges.push(t.readInt32());this.initialized=!0}toString(){let t=super.toString();return t+=`\n${r.LumpType[this.lumpType]}: [${this.surfEdges.join(", ")}]`}}},{"../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\TexDataLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader"),s=t("../Structs/TexData"),i=t("gl-matrix");e.TexDataLump=class extends a.Lump{constructor(t,n){super(r.LumpType.TexData,t,n),this.texDatas=[]}read(){const t=new o.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=3*o.FLOAT_SIZE+5*o.INT_32_SIZE)this.texDatas.push(new s.TexData(i.vec3.fromValues(t.readFloat(),t.readFloat(),t.readFloat()),t.readInt32(),t.readInt32(),t.readInt32(),t.readInt32(),t.readInt32()));this.initialized=!0}toString(){let t=super.toString();return t+=`\n${r.LumpType[this.lumpType]}: ${this.texDatas.join("\n")}`}}},{"../Structs/TexData":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\TexData.js","../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js","gl-matrix":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\node_modules\\gl-matrix\\dist\\gl-matrix.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\TexDataStringDataLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader");e.TexDataStringDataLump=class extends a.Lump{constructor(t,n){super(r.LumpType.TexDataStringData,t,n),this.stringData=[]}read(){const t=new o.BinaryReader(this.data);let n=t.readString(!1);for(;null!=n;)this.stringData.push(n),n=t.readString(!1);this.initialized=!0}toString(){let t=super.toString();return t+=`\n${r.LumpType[this.lumpType]}: [${this.stringData.join(", ")}]`}readStringAtOffset(t){return new o.BinaryReader(this.data,t).readString()}readStrings(t){let n="",e=t.readChar();for(;"\0"!==e&&t.position+o.CHAR_SIZE<=t.length;)n+=e,e=t.readChar()}}},{"../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\TexDataStringTableLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader");e.TexDataStringTableLump=class extends a.Lump{constructor(t,n){super(r.LumpType.TexDataStringTable,t,n),this.texDataTable=[]}read(){const t=new o.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=o.INT_32_SIZE)this.texDataTable.push(t.readInt32());this.initialized=!0}toString(){let t=super.toString();return t+=`\n${r.LumpType[this.lumpType]}: [${this.texDataTable.join(", ")}]`}}},{"../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\TexInfoLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("./LumpType"),o=t("../Utils/BinaryReader"),s=t("../Structs/TexInfo");e.TexInfoLump=class extends a.Lump{constructor(t,n){super(r.LumpType.TexInfo,t,n),this.texInfos=[]}read(){const t=new o.BinaryReader(this.data);for(let n=0;n<this.header.lumpLength;n+=72)this.texInfos.push(new s.TexInfo([[t.readFloat(),t.readFloat(),t.readFloat(),t.readFloat()],[t.readFloat(),t.readFloat(),t.readFloat(),t.readFloat()]],[[t.readFloat(),t.readFloat(),t.readFloat(),t.readFloat()],[t.readFloat(),t.readFloat(),t.readFloat(),t.readFloat()]],t.readInt32(),t.readInt32()));this.initialized=!0}toString(){let t=super.toString();return t+=`\n${r.LumpType[this.lumpType]}: ${this.texInfos.join("\n")}`}}},{"../Structs/TexInfo":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\TexInfo.js","../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\VertexLump.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Lump"),r=t("../Utils/BinaryReader"),o=t("./LumpType"),s=t("gl-matrix");e.VertexLump=class extends a.Lump{constructor(t,n){super(o.LumpType.Vertexes,t,n)}read(){const t=new r.BinaryReader(this.data);this.vertexes=[];for(let n=0;n<this.header.lumpLength;n+=3*r.FLOAT_SIZE)this.vertexes.push(s.vec3.fromValues(t.readFloat(),t.readFloat(),t.readFloat()));this.initialized=!0}toString(){let t=super.toString();return t+=`\n${o.LumpType[this.lumpType]}: [(${this.vertexes.join("), (")}]`}}},{"../Utils/BinaryReader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js","./Lump":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\Lump.js","./LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js","gl-matrix":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\node_modules\\gl-matrix\\dist\\gl-matrix.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\Brush.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Enums");e.Brush=class{constructor(t,n,e){this.firstSide=t,this.numSides=n,this.contents=e}toString(){return`FirstSide: ${this.firstSide}\n\t\tNumSides: ${this.numSides}\n\t\tContents: ${a.BrushContent[this.contents]}`}}},{"./Enums":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\Enums.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\BrushSide.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.BrushSide=class{constructor(t,n,e,a){this.planeNum=t,this.texInfo=n,this.dispInfo=e,this.bevel=a}toString(){return`PlaneNum: ${this.planeNum}\n\t\ttexInfo: ${this.texInfo}\n\t\tdispInfo: ${this.dispInfo}\n\t\tbevel: ${this.bevel}`}}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\ColorRGBExp32.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.ColorRGBExp32=class{constructor(t,n,e,a){this.r=t,this.g=n,this.b=e,this.e=a}toString(){return`RGBE: [${this.r}, ${this.g}, ${this.b}] ${this.e}`}}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\CompressedLightCube.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.CompressedLightCube=class{constructor(t){this.color=t}toString(){return`Color:\n\t${this.color.join("\n\t")}`}}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\Cubemap.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.Cubemap=class{constructor(t,n){this.origin=t,this.size=n}toString(){return`Origin: [${this.origin}]\n\t\tSize: ${this.size}`}}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\DispCornerNeighbor.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.DispCornerNeighbors=class{constructor(t,n){this.neighbors=t,this.nNeighbors=n}toString(){return`neighbors: [${this.neighbors[0]},\n\t\t${this.neighbors[1]}, \n\t\t${this.neighbors[2]}, \n\t\t${this.neighbors[3]}]\n\t\tnumNeighbors: ${this.nNeighbors}\n\t`}}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\DispInfo.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.DispInfo=class{constructor(t,n,e,a,r,o,s,i,u,m,c,l,p){this.startPosition=t,this.dispVertStart=n,this.dispTriStart=e,this.power=a,this.minTess=r,this.smoothingAngle=o,this.contents=s,this.mapFace=i,this.lightmapAlphaStart=u,this.lightmapSamplePositionStart=m,this.edgeNeighbors=c,this.cornerNeighbors=l,this.allowedVerts=p}numVerts(){return(1+(1<<this.power))*(1+(1<<this.power))}numTris(){return(1<<this.power)*(1<<this.power)*2}numRows(){return Math.pow(2,this.power)+1}toString(){return`StartPos: ${this.startPosition}\n\t\tDispVertStart: ${this.dispVertStart}\n\t\tDispTriStart: ${this.dispTriStart}\n\t\tPower: ${this.power}\n\t\tMin Tess: ${this.minTess}\n\t\tSmoothing Angle: ${this.smoothingAngle}\n\t\tContents: ${this.contents}\n\t\tMap Face: ${this.mapFace}\n\t\tLightmapAlphaStart: ${this.lightmapAlphaStart}\n\t\tLightmapSamplePositionStart: ${this.lightmapSamplePositionStart}\n\t\tCornerNeighbors: \n\t\t\t${[this.cornerNeighbors.join("\n\t\t\t")]}\n\t\tEdgeNeighbors: \n\t\t\t${[this.edgeNeighbors.join("\n\t\t\t")]}\n\t\tAllowedVerts: ${this.allowedVerts}\n\t\t`}}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\DispNeighbor.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.DispNeighbor=class{constructor(t){this.subNeighbors=t}toString(){return`[\n\t${this.subNeighbors[0]}, \n\t${this.subNeighbors[1]}\n\t]`}}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\DispSubNeighbor.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.DispSubNeighbor=class{constructor(t,n,e,a){this.iNeighbor=t,this.neighborOrientation=n,this.span=e,this.neighborSpan=a}toString(){return`iNeighbor: ${this.iNeighbor}\n\tneighborOrientation: ${this.neighborOrientation}\n\tspan: ${this.span}\n\tneighborSpan: ${this.neighborSpan}\n\t\t`}}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\DispVert.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.DispVert=class{constructor(t,n,e){this.vec=t,this.dist=n,this.alpha=e}toString(){return`vec: ${this.vec}\ndist: ${this.dist}\nalpha: ${this.alpha}\n\t\t`}}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\Edge.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class a{constructor(t,n){this.vertexIndices=[t,n]}reverse(){return new a(this.vertexIndices[1],this.vertexIndices[0])}getVertIndices(t=!1){if(t){this.reverse();return this.reverse().vertexIndices}return this.vertexIndices}toString(){return`[${this.vertexIndices[0]}, ${this.vertexIndices[1]}]`}}e.Edge=a},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\Enums.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),function(t){t[t.EMPTY=0]="EMPTY",t[t.SOLID=1]="SOLID",t[t.WINDOW=2]="WINDOW",t[t.AUX=4]="AUX",t[t.GRATE=8]="GRATE",t[t.SLIME=16]="SLIME",t[t.WATER=32]="WATER",t[t.MIST=64]="MIST",t[t.OPAQUE=128]="OPAQUE",t[t.TEST_FOG_VOLUME=256]="TEST_FOG_VOLUME",t[t.UNUSED=512]="UNUSED",t[t.UNUSED6=1024]="UNUSED6",t[t.TEAM1=2048]="TEAM1",t[t.TEAM2=4096]="TEAM2",t[t.IGNORE_DRAW_OPAQUE=8192]="IGNORE_DRAW_OPAQUE",t[t.MOVEABLE=16384]="MOVEABLE",t[t.AREAPORTAL=32768]="AREAPORTAL",t[t.PLAYERCLIP=65536]="PLAYERCLIP",t[t.MONSTERCLIP=131072]="MONSTERCLIP",t[t.CURRENT_0=262144]="CURRENT_0",t[t.CURRENT_90=524288]="CURRENT_90",t[t.CURRENT_180=1048576]="CURRENT_180",t[t.CURRENT_270=2097152]="CURRENT_270",t[t.CURRENT_UP=4194304]="CURRENT_UP",t[t.CURRENT_DOWN=8388608]="CURRENT_DOWN",t[t.ORIGIN=16777216]="ORIGIN",t[t.MONSTER=33554432]="MONSTER",t[t.DEBRIS=67108864]="DEBRIS",t[t.DETAIL=134217728]="DETAIL",t[t.TRANSLUCENT=268435456]="TRANSLUCENT",t[t.LADDER=536870912]="LADDER",t[t.HITBOX=1073741824]="HITBOX"}(e.BrushContent||(e.BrushContent={})),function(t){t[t.LIGHT=1]="LIGHT",t[t.SKY2D=2]="SKY2D",t[t.SKY=4]="SKY",t[t.WARP=8]="WARP",t[t.TRANS=16]="TRANS",t[t.NO_PORTAL=32]="NO_PORTAL",t[t.TRIGGER=64]="TRIGGER",t[t.NODRAW=128]="NODRAW",t[t.HINT=256]="HINT",t[t.SKIP=512]="SKIP",t[t.NO_LIGHT=1024]="NO_LIGHT",t[t.BUMP_LIGHT=2048]="BUMP_LIGHT",t[t.NO_SHADOWS=4096]="NO_SHADOWS",t[t.NO_DECALS=8192]="NO_DECALS",t[t.NO_CHOP=16384]="NO_CHOP",t[t.HITBOX=32768]="HITBOX"}(e.SurfFlags||(e.SurfFlags={})),function(t){t[t.CHILDNODE_UPPER_RIGHT=0]="CHILDNODE_UPPER_RIGHT",t[t.CHILDNODE_UPPER_LEFT=1]="CHILDNODE_UPPER_LEFT",t[t.CHILDNODE_LOWER_LEFT=2]="CHILDNODE_LOWER_LEFT",t[t.CHILDNODE_LOWER_RIGHT=3]="CHILDNODE_LOWER_RIGHT"}(e.DispChildNode||(e.DispChildNode={})),function(t){t[t.CORNER_LOWER_LEFT=0]="CORNER_LOWER_LEFT",t[t.CORNER_UPPER_LEFT=1]="CORNER_UPPER_LEFT",t[t.CORNER_UPPER_RIGHT=3]="CORNER_UPPER_RIGHT",t[t.CORNER_LOWER_RIGHT=2]="CORNER_LOWER_RIGHT"}(e.DispCorner||(e.DispCorner={})),function(t){t[t.NEIGHBOREDGE_LEFT=0]="NEIGHBOREDGE_LEFT",t[t.NEIGHBOREDGE_TOP=1]="NEIGHBOREDGE_TOP",t[t.NEIGHBOREDGE_RIGHT=2]="NEIGHBOREDGE_RIGHT",t[t.NEIGHBOREDGE_BOTTOM=3]="NEIGHBOREDGE_BOTTOM"}(e.DispNeighborEdge||(e.DispNeighborEdge={})),function(t){t[t.CORNER_TO_CORNER=0]="CORNER_TO_CORNER",t[t.CORNER_TO_MIDPOINT=1]="CORNER_TO_MIDPOINT",t[t.MIDPOINT_TO_CORNER=2]="MIDPOINT_TO_CORNER"}(e.DispSpan||(e.DispSpan={})),function(t){t[t.ORIENTATION_CCW_0=0]="ORIENTATION_CCW_0",t[t.ORIENTATION_CCW_90=1]="ORIENTATION_CCW_90",t[t.ORIENTATION_CCW_180=2]="ORIENTATION_CCW_180",t[t.ORIENTATION_CCW_270=3]="ORIENTATION_CCW_270"}(e.DispOrientation||(e.DispOrientation={})),function(t){t[t.DISPTRI_TAG_SURFACE=1]="DISPTRI_TAG_SURFACE",t[t.DISPTRI_TAG_WALKABLE=2]="DISPTRI_TAG_WALKABLE",t[t.DISPTRI_TAG_BUILDABLE=4]="DISPTRI_TAG_BUILDABLE",t[t.DISPTRI_FLAG_SURFPROP1=8]="DISPTRI_FLAG_SURFPROP1",t[t.DISPTRI_FLAG_SURFPROP2=16]="DISPTRI_FLAG_SURFPROP2"}(e.DispTags||(e.DispTags={}))},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\Face.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.Face=class{constructor(t,n,e,a,r,o,s,i,u,m,c,l,p,d,b,h,v){this.planeNum=t,this.side=n,this.onNode=e,this.firstEdge=a,this.numEdges=r,this.texInfo=o,this.dispInfo=s,this.surfaceFogVolumeID=i,this.style=u,this.lightOfs=m,this.area=c,this.lightmapTextureMinsInLuxels=l,this.lightmapTextureSizeInLuxels=p,this.origFace=d,this.numPrims=b,this.firstPrimID=h,this.smoothingGroups=v}toString(){return`PlaneNum: ${this.planeNum}\n\t\tSide: ${this.side}\n\t\tFirst Edge: ${this.firstEdge}\n\t\tNum Edges: ${this.numEdges}\n\t\tSmoothing Group: ${this.smoothingGroups}\n\t\t`}}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\GameLumpStruct.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.GameLumpStruct=class{constructor(t,n,e,a,r){this.id=t,this.flags=n,this.version=e,this.fileOffset=a,this.fileLength=r}toString(){return`ID: ${this.id}\n\t\tFlags: ${this.flags}\n\t\tVersion: ${this.version}\n\t\tFileOffset: ${this.fileOffset}\n\t\tFileLegnth: ${this.fileLength}\n\t\t`}}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\Leaf.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.Leaf=class{constructor(t,n,e,a,r,o,s,i,u,m,c){this.contents=t,this.cluster=n,this.area=e,this.flags=a,this.mins=r,this.maxs=o,this.firstLeafFace=s,this.numLeafFaces=i,this.firstLeafBrush=u,this.numLeafBrushes=m,this.leafWaterDataID=c}toString(){return`Contents: ${this.contents} \n\t\t\tCluster: ${this.cluster}\n\t\t\tArea: ${this.area}\n\t\t\tFlags: ${this.flags}\n\t\t\tMins: ${this.mins}\n\t\t\tMaxs: ${this.maxs}\n\t\t\tFirstLeafBrush: ${this.firstLeafBrush}\n\t\t\tNumLeafFaces: ${this.numLeafFaces}\n\t\t\tFirstLeafBrush: ${this.firstLeafBrush}\n\t\t\tNumLeafBrushes: ${this.numLeafBrushes}\n\t\t\tLeafWaterDataID: ${this.leafWaterDataID}\n\t\t\t`}}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\LeafAmbientIndex.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.LeafAmbientIndex=class{constructor(t,n){this.ambientSampleCount=t,this.firstAmbientSample=n}toString(){return`AmbientSampleCount: ${this.ambientSampleCount}\nFirstAmbientSample: ${this.firstAmbientSample}`}}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\LeafAmbientLighting.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.LeafAmbientLighting=class{constructor(t,n,e,a,r){this.cube=t,this.x=n,this.y=e,this.z=a,this.pad=r}toString(){return`Cube: \n${this.cube}\nXYZ: [${this.x}, ${this.y}, ${this.z}]`}}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\Model.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.Model=class{constructor(t,n,e,a,r,o){this.mins=t,this.maxs=n,this.origin=e,this.headNode=a,this.firstFace=r,this.numFaces=o}toString(){return`Mins: ${this.mins}\n\t\tMaxs: ${this.maxs} \n\t\tOrigin: ${this.origin} \n\t\tHeadNode: ${this.headNode} \n\t\tFirstFace: ${this.firstFace} \n\t\tNumFaces: ${this.numFaces} \n\t\t`}}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\Node.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.Node=class{constructor(t,n,e,a,r,o,s,i){this.planeNum=t,this.children=n,this.mins=e,this.maxs=a,this.firstFace=r,this.numFaces=o,this.area=s,this.padding=i}toString(){return`Node: \n\t\t\tPlaneNum: ${this.planeNum}\n\t\t\tChildren: ${this.children}\n\t\t\tMins: [${this.mins.join(", ")}]\n\t\t\tMaxs: [${this.maxs.join(", ")}]\n\t\t\tFirstFace: ${this.firstFace}\n\t\t\tNumFaces: ${this.numFaces}\n\t\t\tArea: ${this.area}\n\t\t\t`}}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\Plane.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.Plane=class{constructor(t,n,e){this.normal=t,this.dist=n,this.type=e}toString(){return`Normal: ${this.normal}\n\t\tDistance From Origin: ${this.dist}\n\t\tType: ${this.type}\n\t\t`}}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\TexData.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.TexData=class{constructor(t,n,e,a,r,o){this.reflectivity=t,this.nameDataStringTableID=n,this.width=e,this.height=a,this.viewWidth=r,this.viewHeight=o}toString(){return`Reflectivity: [${this.reflectivity}]\n\t\tNameDataStringTableID: ${this.nameDataStringTableID}\n\t\tWidth: ${this.width}\n\t\tHeight: ${this.height}\n\t\tViewWidth: ${this.viewWidth}\n\t\tViewHeight: ${this.viewHeight}`}}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\TexInfo.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.TexInfo=class{constructor(t,n,e,a){this.textureVecs=t,this.lightmapVecs=n,this.flags=e,this.texData=a}toString(){return`Texture Vecs: [${this.textureVecs.join("], [")}]\n\t\tLightmap Vecs: [${this.lightmapVecs.join("], [")}]\n\t\tFlags: ${this.flags}\n\t\tTexData: ${this.texData}`}}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Utils\\BinaryReader.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.INT_8_SIZE=1,e.INT_16_SIZE=2,e.INT_32_SIZE=4,e.UINT_8_SIZE=1,e.UINT_16_SIZE=2,e.UINT_32_SIZE=4,e.FLOAT_SIZE=4,e.DOUBLE_SIZE=8,e.BOOL_SIZE=1,e.CHAR_SIZE=1;var a,r;e.BinaryReader=class{constructor(t,n=0,e=r.LittleEndian){this.dataView=new DataView(t),e===r.LittleEndian?this.isLittleEndian=!0:this.isLittleEndian=!1,this.position=n,this.length=t.byteLength}readInt8(){if(this.position+e.INT_8_SIZE>this.length)throw new Error("RangeError");const t=this.dataView.getInt8(this.position);return this.position+=e.INT_8_SIZE,t}readInt16(){if(this.position+e.INT_16_SIZE>this.length)throw new Error("RangeError");const t=this.dataView.getInt16(this.position,this.isLittleEndian);return this.position+=e.INT_16_SIZE,t}readInt32(){if(this.position+e.INT_32_SIZE>this.length)throw new Error("RangeError");const t=this.dataView.getInt32(this.position,this.isLittleEndian);return this.position+=e.INT_32_SIZE,t}readUInt8(){if(this.position+e.UINT_8_SIZE>this.length)throw new Error("RangeError");const t=this.dataView.getUint8(this.position);return this.position+=e.UINT_8_SIZE,t}readUInt16(){if(this.position+e.UINT_16_SIZE>this.length)throw new Error("RangeError");const t=this.dataView.getUint16(this.position,this.isLittleEndian);return this.position+=e.UINT_16_SIZE,t}readUInt32(){if(this.position+e.UINT_32_SIZE>this.length)throw new Error("RangeError");const t=this.dataView.getUint16(this.position,this.isLittleEndian);return this.position+=e.UINT_32_SIZE,t}readFloat(){if(this.position+e.FLOAT_SIZE>this.length)throw new Error("RangeError");const t=this.dataView.getFloat32(this.position,this.isLittleEndian);return this.position+=e.FLOAT_SIZE,t}readDouble(){if(this.position+e.DOUBLE_SIZE>this.length)throw new Error("RangeError");const t=this.dataView.getFloat64(this.position,this.isLittleEndian);return this.position+=e.DOUBLE_SIZE,t}readBoolean(){if(this.position+e.BOOL_SIZE>this.length)throw new Error("RangeError");const t=0===this.dataView.getInt8(this.position);return this.position+=e.BOOL_SIZE,t}readBytes(t){if(this.position+t>this.length)throw new Error("RangeError");const n=new Uint8Array(this.dataView.buffer,this.position,t);return this.position+=t,n}readChar(){if(this.position+e.CHAR_SIZE>this.length)throw new Error("RangeError");const t=String.fromCharCode(this.dataView.getInt8(this.position));return this.position+=e.CHAR_SIZE,t}peekChar(){if(this.position+e.CHAR_SIZE>this.length)throw new Error("RangeError");return String.fromCharCode(this.dataView.getInt8(this.position))}readString(t=!0){if(this.position+e.CHAR_SIZE>this.length){if(t)throw new Error("RangeError");return null}let n="",a=this.readChar();for(;"\0"!==a&&this.position+e.CHAR_SIZE<=this.length;)n+=a,a=this.readChar();return n}seek(t,n){switch(n){case a.Beginning:if(t>this.length)throw new Error("RangeError");this.position=t;break;case a.Current:if(this.position+t>this.length)throw new Error("RangeError");this.position+=t;break;case a.End:if(this.length+t>this.length)throw new Error("RangeError");this.position=this.length+t}}},function(t){t[t.Current=0]="Current",t[t.Beginning=1]="Beginning",t[t.End=2]="End"}(a=e.SeekOrigin||(e.SeekOrigin={})),function(t){t[t.LittleEndian=0]="LittleEndian",t[t.BigEndian=1]="BigEndian"}(r=e.Endianness||(e.Endianness={}))},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\KeyboardListener.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var a=t("./Rendering/Camera/ICamera"),r=t("./Rendering/Messaging/Message"),o=t("./Utils/KeyPress"),s=function(){function t(t){var n=this;this.componentName="KeyboardListener",this.listen=!0,this.zToggle=!1,this.wPressed=!1,this.aPressed=!1,this.sPressed=!1,this.dPressed=!1,window.addEventListener("keydown",function(e){switch(e.key){case"W":case"w":n.wPressed=!0;break;case"A":case"a":n.aPressed=!0;break;case"S":case"s":n.sPressed=!0;break;case"D":case"d":n.dPressed=!0;break;case"Z":case"z":n.zToggle=!n.zToggle,t.messageQueue.add(new r.Message(t,n,r.MessageType.Keypress,new o.KeyPress(o.Key.Z),r.MessagePriority.High)),t.messageQueue.add(new r.Message(t,n,r.MessageType.ToggleRender,n.zToggle));break;case"Shift":t.messageQueue.add(new r.Message(t,n,r.MessageType.Keypress,new o.KeyPress(null,o.KeyState.Keydown,o.KeyModifier.Shift),r.MessagePriority.High));break;case"Escape":n.zToggle=!1,console.log("escape"),t.messageQueue.add(new r.Message(t,n,r.MessageType.Keypress,new o.KeyPress(o.Key.Escape)))}}),window.addEventListener("keyup",function(e){switch(e.key){case"W":case"w":n.wPressed=!1;break;case"A":case"a":n.aPressed=!1;break;case"S":case"s":n.sPressed=!1;break;case"D":case"d":n.dPressed=!1;break;case"Shift":t.messageQueue.add(new r.Message(t,n,r.MessageType.Keypress,new o.KeyPress(null,o.KeyState.Keyup,o.KeyModifier.Shift),r.MessagePriority.High))}})}return t.prototype.pollKeyboard=function(t){this.wPressed&&this.zToggle&&t.messageQueue.add(new r.Message(t,this,r.MessageType.MoveCamera,a.MoveDirection.forward)),this.sPressed&&this.zToggle&&t.messageQueue.add(new r.Message(t,this,r.MessageType.MoveCamera,a.MoveDirection.backward)),this.dPressed&&this.zToggle&&t.messageQueue.add(new r.Message(t,this,r.MessageType.MoveCamera,a.MoveDirection.right)),this.aPressed&&this.zToggle&&t.messageQueue.add(new r.Message(t,this,r.MessageType.MoveCamera,a.MoveDirection.left))},t.prototype.onMessage=function(t){},t}();e.KeyboardListener=s},{"./Rendering/Camera/ICamera":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\Camera\\ICamera.js","./Rendering/Messaging/Message":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\Messaging\\Message.js","./Utils/KeyPress":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Utils\\KeyPress.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\MouseHandler.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var a=t("./Rendering/Messaging/Message"),r=t("gl-matrix"),o=function(){function t(t){this.componentName="MouseHandler",this._active=!1,document.addEventListener("mousemove",this.mouseCallback.bind(this,t)),document.addEventListener("pointerlockchange",this.pointerLockChanged.bind(this,t)),document.addEventListener("pointerlockerror",function(){return console.log("Pointer lock failed")})}return Object.defineProperty(t.prototype,"active",{get:function(){return this._active},set:function(t){var n=document.getElementById("canvas");n?(t?n.requestPointerLock():document.exitPointerLock(),this._active=t):console.log("Failed to find canvas element")},enumerable:!0,configurable:!0}),t.prototype.mouseCallback=function(t,n){this.active&&t.messageQueue.add(new a.Message(t,this,a.MessageType.MouseMove,r.vec2.fromValues(n.movementX,n.movementY),a.MessagePriority.High))},t.prototype.pointerLockChanged=function(t,n){document.pointerLockElement!==document.getElementById("canvas")&&t.messageQueue.add(new a.Message(t,this,a.MessageType.ToggleCameraActive,!1))},t.prototype.onMessage=function(t){switch(t.type){case a.MessageType.ToggleCameraActive:this.active=t.data}},t}();e.MouseHandler=o},{"./Rendering/Messaging/Message":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\Messaging\\Message.js","gl-matrix":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\node_modules\\gl-matrix\\dist\\gl-matrix.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\Camera\\ICamera.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),function(t){t[t.forward=0]="forward",t[t.backward=1]="backward",t[t.left=2]="left",t[t.right=3]="right"}(e.MoveDirection||(e.MoveDirection={}))},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\Camera\\PerspectiveCamera.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var a=t("gl-matrix"),r=t("../../Utils/WrapAngle"),o=t("../../Utils/LimitAngle"),s=t("./ICamera"),i=t("../Messaging/Message"),u=function(){function t(t,n){this.componentName="PerspectiveCamera",this.horizontalFov=45,this.speed=10,this.mulitplier=1,this.mouseSensitivity=5,this.up=a.vec3.fromValues(0,1,0),this.modelMatrix=a.mat4.identity(a.mat4.create()),this.nearClip=1,this.farClip=1e4,console.log("--Initializing Perspective Camera--"),console.log("\tCanvas Width: "+t),console.log("\tCanvas Height: "+n),0===n?(console.log("Error, height cannot be 0"),this.aspectRatio=0):this.aspectRatio=t/n,console.log("\tAspect Ratio: "+this.aspectRatio),this.position=a.vec3.fromValues(0,0,0),this.horizontalAngle=0,this.verticalAngle=0,a.mat4.rotateX(this.modelMatrix,this.modelMatrix,a.glMatrix.toRadian(-90)),this.getProjectionMatrix()}return Object.defineProperty(t.prototype,"horizontalAngle",{get:function(){return this._horizontalAngle},set:function(t){this._horizontalAngle=r.wrapAngle(t)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"verticalAngle",{get:function(){return this._verticalAngle},set:function(t){this._verticalAngle=o.limitAngle(t,-89,89)},enumerable:!0,configurable:!0}),t.prototype.getFront=function(){var t=a.vec3.create();return t[0]=Math.cos(a.glMatrix.toRadian(this.verticalAngle))*Math.cos(a.glMatrix.toRadian(this.horizontalAngle)),t[1]=Math.sin(a.glMatrix.toRadian(this.verticalAngle)),t[2]=Math.cos(a.glMatrix.toRadian(this.verticalAngle))*Math.sin(a.glMatrix.toRadian(this.horizontalAngle)),a.vec3.normalize(t,t),t},t.prototype.getRight=function(){var t=this.getFront(),n=a.vec3.create();return a.vec3.cross(n,t,this.up),a.vec3.normalize(n,n),n},t.prototype.getProjectionMatrix=function(){var t=a.mat4.create();return a.mat4.perspective(t,a.glMatrix.toRadian(this.horizontalFov),this.aspectRatio,this.nearClip,this.farClip),t},t.prototype.getViewMatrix=function(){var t=a.vec3.create();a.vec3.add(t,this.position,this.getFront());var n=a.mat4.create();return a.mat4.lookAt(n,this.position,t,this.up),n},t.prototype.getModelMatrix=function(){return this.modelMatrix},t.prototype.updateAspectRatio=function(t,n){0!==n?this.aspectRatio=t/n:console.log("Error, height cannot be 0")},t.prototype.move=function(t){switch(t){case s.MoveDirection.forward:this.moveForward();break;case s.MoveDirection.backward:this.moveBackword();break;case s.MoveDirection.left:this.moveLeft();break;case s.MoveDirection.right:this.moveRight()}},t.prototype.moveForward=function(){var t=this.getFront();this.position[0]+=this.speed*this.mulitplier*t[0],this.position[1]+=this.speed*this.mulitplier*t[1],this.position[2]+=this.speed*this.mulitplier*t[2]},t.prototype.moveBackword=function(){var t=this.getFront();this.position[0]-=this.speed*this.mulitplier*t[0],this.position[1]-=this.speed*this.mulitplier*t[1],this.position[2]-=this.speed*this.mulitplier*t[2]},t.prototype.moveRight=function(){var t=this.getRight();this.position[0]+=this.speed*this.mulitplier*t[0],this.position[1]+=this.speed*this.mulitplier*t[1],this.position[2]+=this.speed*this.mulitplier*t[2]},t.prototype.moveLeft=function(){var t=this.getRight();this.position[0]-=this.speed*this.mulitplier*t[0],this.position[1]-=this.speed*this.mulitplier*t[1],this.position[2]-=this.speed*this.mulitplier*t[2]},t.prototype.update=function(t,n,e){this.horizontalAngle+=t*e*this.mouseSensitivity,this.verticalAngle+=-n*e*this.mouseSensitivity},t.prototype.onMessage=function(t){switch(t.type){case i.MessageType.MoveCamera:this.move(t.data);break;case i.MessageType.MouseMove:var n=t.data;this.update(n[0],n[1],n[2])}},t}();e.PerspectiveCamera=u},{"../../Utils/LimitAngle":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Utils\\LimitAngle.js","../../Utils/WrapAngle":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Utils\\WrapAngle.js","../Messaging/Message":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\Messaging\\Message.js","./ICamera":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\Camera\\ICamera.js","gl-matrix":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\node_modules\\gl-matrix\\dist\\gl-matrix.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\CoreEngine.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var a=t("./Shaders/ShaderSource"),r=t("./Shaders/Shader"),o=t("../KeyboardListener"),s=t("../MouseHandler"),i=t("./Camera/PerspectiveCamera"),u=t("gl-matrix"),m=t("./UniformLocations"),c=t("./Messaging/MessageQueue"),l=t("./Messaging/Message"),p=t("../Utils/KeyPress"),d=function(){function t(n){this.componentName="CoreEngine",this.controlsActive=!1,this.gridSize=15,this.drawGrid=!0,this.defaultShaders=[a.FragShader,a.VertShader],this.renderObjects=[],this.previousTime=0,this.deltaTime=0,this.renderFrame=!1,console.log("--Initializing Core--"),this.gl=n,this.messageQueue=new c.MessageQueue,this.gl.clearColor(0,0,0,1),this.gl.clearDepth(1),this.gl.enable(this.gl.CULL_FACE),this.gl.cullFace(this.gl.FRONT),this.gl.enable(this.gl.DEPTH_TEST),this.gl.depthFunc(this.gl.LEQUAL),this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT),this.cameras=[new i.PerspectiveCamera(this.gl.canvas.clientWidth,this.gl.canvas.clientHeight)],this.activeCamera=this.cameras[0],this.defaultShaderProgram=r.CreateShaderProgram(this.gl,this.defaultShaders),null!=this.defaultShaderProgram&&void 0!==this.defaultShaderProgram&&(this.uniformLocations=new m.UniformLocations(this.gl,this.defaultShaderProgram),this.gl.uniform1i(this.uniformLocations.uTextureArrayLocation,0),this.keyboardListener=new o.KeyboardListener(this),this.mouseHandler=new s.MouseHandler(this),t.renderer=this)}return Object.defineProperty(t,"renderer",{get:function(){return t._renderer},set:function(n){t._renderer=n},enumerable:!0,configurable:!0}),t.prototype.addRenderableObject=function(t){this.renderObjects.push(t)},t.prototype.clearRenderObjects=function(){this.renderObjects=[]},t.prototype.main=function(t){void 0===t&&(t=0),window.requestAnimationFrame(this.main.bind(this)),this.messageQueue.dispatch(),this.keyboardListener.pollKeyboard(this),this.deltaTime=(t-this.previousTime)/1e3,this.previousTime=t,this.renderFrame&&this.render()},t.prototype.render=function(){var t=this;this.resize(),this.gl.viewport(0,0,this.gl.drawingBufferWidth,this.gl.drawingBufferHeight),this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT),this.gl.useProgram(this.defaultShaderProgram),this.gl.uniformMatrix4fv(this.uniformLocations.uModelMatLocation,!1,this.activeCamera.getModelMatrix()),this.gl.uniformMatrix4fv(this.uniformLocations.uViewMatLocation,!1,this.activeCamera.getViewMatrix()),this.gl.uniformMatrix4fv(this.uniformLocations.uProjectionMatrixLocation,!1,this.activeCamera.getProjectionMatrix()),this.renderObjects.forEach(function(n){n.draw(t.gl)})},t.prototype.resize=function(){var t=window.devicePixelRatio||1,n=Math.floor(this.gl.canvas.clientWidth*t),e=Math.floor(this.gl.canvas.clientHeight*t);this.gl.canvas.width===n&&this.gl.canvas.height===e||(this.gl.canvas.width=n,this.gl.canvas.height=e,this.activeCamera.updateAspectRatio(n,e))},t.prototype.onMessage=function(t){switch(t.type){case l.MessageType.ToggleCameraActive:this.controlsActive=t.data,this.mouseHandler.active=t.data,this.keyboardListener.zToggle=t.data,this.renderFrame=t.data;break;case l.MessageType.ToggleRender:this.renderFrame=t.data;break;case l.MessageType.MoveCamera:this.activeCamera.onMessage(t);break;case l.MessageType.MouseMove:this.activeCamera.onMessage(new l.Message(this.activeCamera,this,l.MessageType.MouseMove,u.vec3.fromValues(t.data[0],t.data[1],this.deltaTime)));break;case l.MessageType.Keypress:switch(t.data.key){case p.Key.Z:this.controlsActive=!this.controlsActive,this.renderFrame=!this.renderFrame,this.mouseHandler.active=this.controlsActive;break;case p.Key.Escape:this.controlsActive=!1,this.renderFrame=!1,this.mouseHandler.active=!1;default:switch(t.data.modifier){case p.KeyModifier.Shift:t.data.state===p.KeyState.Keydown?this.activeCamera.mulitplier=5:this.activeCamera.mulitplier=1}}}},t}();e.CoreEngine=d},{"../KeyboardListener":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\KeyboardListener.js","../MouseHandler":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\MouseHandler.js","../Utils/KeyPress":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Utils\\KeyPress.js","./Camera/PerspectiveCamera":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\Camera\\PerspectiveCamera.js","./Messaging/Message":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\Messaging\\Message.js","./Messaging/MessageQueue":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\Messaging\\MessageQueue.js","./Shaders/Shader":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\Shaders\\Shader.js","./Shaders/ShaderSource":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\Shaders\\ShaderSource.js","./UniformLocations":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\UniformLocations.js","gl-matrix":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\node_modules\\gl-matrix\\dist\\gl-matrix.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\Messaging\\Message.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var a,r,o=function(){function t(t,n,e,r,o){void 0===o&&(o=a.Low),t instanceof Array?this.to=t:this.to=[t],this.from=n,this.type=e,this.data=r,this.priority=o}return t.prototype.toString=function(){var t=this,n="";return this.to.forEach(function(e){n+=t.from.componentName+" -> "+e.componentName+" - "+a[t.priority]+":\n",n+=t.data+" ("+r[t.type]+")\n"}),n},t}();e.Message=o,function(t){t[t.High=0]="High",t[t.Medium=1]="Medium",t[t.Low=2]="Low"}(a=e.MessagePriority||(e.MessagePriority={})),function(t){t[t.ToggleCameraActive=0]="ToggleCameraActive",t[t.Keypress=1]="Keypress",t[t.ToggleRender=2]="ToggleRender",t[t.MoveCamera=3]="MoveCamera",t[t.MouseMove=4]="MouseMove"}(r=e.MessageType||(e.MessageType={}))},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\Messaging\\MessageQueue.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Message");e.MessageQueue=class{constructor(t=!1){this.lowPriorityMessages=[],this.mediumPriorityMessages=[],this.logging=t}add(t){switch(t.priority){case a.MessagePriority.High:this.dispatchMessage(t);break;case a.MessagePriority.Medium:this.mediumPriorityMessages.push(t);case a.MessagePriority.Low:this.lowPriorityMessages.push(t)}}dispatch(){for(let t=0;t<this.mediumPriorityMessages.length;t++){const t=this.mediumPriorityMessages.shift();this.dispatchMessage(t)}for(let t=0;t<this.lowPriorityMessages.length;t++){const t=this.lowPriorityMessages.shift();this.dispatchMessage(t)}}dispatchMessage(t){if(t){this.logging&&console.log(t.toString());const n=t.to;n&&n.forEach(n=>{n.onMessage(t)})}}}},{"./Message":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\Messaging\\Message.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\RenderObjects\\BSPFace.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("../../Structs/Vertex"),r=t("../../BSP/Lumps/LumpType"),o=t("gl-matrix"),s=t("../../Utils/AddRange"),i=t("../../BSP/Structs/Enums"),u=t("./IRenderable");class m{constructor(t,n){this.visibility=u.Visibility.Visible,this.indices=[],this.face=t,this.vertices=this.getVertices(n)}calcIndices(t){null!=this.dispInfo?this.calcDispIndices(t):this.calcFaceIndices(t)}calcFaceIndices(t){for(let n=1;n<this.vertices.length-1;n++)s.addRange(this.indices,[t,t+n,t+n+1])}calcDispIndices(t){if(null==this.dispInfo)return console.log("Disp info was null!"),console.log(this),[];const n=this.dispInfo.numRows();for(let e=0;e<n-1;e++){const a=e*n;for(let r=0;r<Math.pow(2,this.dispInfo.power-1);r++){const o=a+2*r;e%2==0?(this.indices.push(o+t),this.indices.push(o+n+t),this.indices.push(o+n+1+t),this.indices.push(o+t),this.indices.push(o+n+1+t),this.indices.push(o+1+t),this.indices.push(o+1+t),this.indices.push(o+n+1+t),this.indices.push(o+2+t),this.indices.push(o+2+t),this.indices.push(o+n+1+t),this.indices.push(o+n+2+t)):(this.indices.push(o+1+t),this.indices.push(o+t),this.indices.push(o+n+t),this.indices.push(o+1+t),this.indices.push(o+n+t),this.indices.push(o+n+1+t),this.indices.push(o+1+t),this.indices.push(o+n+1+t),this.indices.push(o+n+2+t),this.indices.push(o+1+t),this.indices.push(o+n+2+t),this.indices.push(o+2+t))}}}getMesh(){return m.verticesToBuffer(this.vertices)}getVertices(t){const n=t.readLump(r.LumpType.TexInfo),e=t.readLump(r.LumpType.TexData),a=t.readLump(r.LumpType.TexDataStringTable),s=t.readLump(r.LumpType.TexDataStringData),m=n.texInfos[this.face.texInfo],c=e.texDatas[m.texData],l=a.texDataTable[c.nameDataStringTableID];s.readStringAtOffset(l);let p;if((m.flags&i.SurfFlags.TRANS)===i.SurfFlags.TRANS&&(this.visibility=u.Visibility.Hidden),(m.flags&i.SurfFlags.TRIGGER)===i.SurfFlags.TRIGGER&&(this.visibility=u.Visibility.Hidden),(m.flags&i.SurfFlags.SKY)!==i.SurfFlags.SKY&&(m.flags&i.SurfFlags.SKY2D)!==i.SurfFlags.SKY2D||(this.visibility=u.Visibility.Hidden),(m.flags&i.SurfFlags.SKIP)!==i.SurfFlags.SKIP&&(m.flags&i.SurfFlags.HINT)!==i.SurfFlags.HINT||(this.visibility=u.Visibility.Hidden),(m.flags&i.SurfFlags.HITBOX)===i.SurfFlags.HITBOX&&(this.visibility=u.Visibility.Hidden),-1===m.texData)p=o.vec4.fromValues(0,1,1,1);else{const t=c.reflectivity;p=o.vec4.fromValues(t[0],t[1],t[2],1)}return-1===this.face.dispInfo?this.getFaceVertexes(t):this.getDispVertexes(t)}getDispVertexes(t){const n=t.readLump(r.LumpType.DispVerts),e=(t.readLump(r.LumpType.DispTris),t.readLump(r.LumpType.DispInfo));this.dispInfo=e.dispInfos[this.face.dispInfo];const i=this.dispInfo.numRows();let u=this.getFaceVertexes(t);for(let t=0;t<u.length;t++){const n=u[t];if(o.vec3.equals(o.vec3.round(o.vec3.create(),n.position),o.vec3.round(o.vec3.create(),this.dispInfo.startPosition))){const n=u.slice(t),e=u.slice(0,t);s.addRange(n,e),u=n;break}}if(4!==u.length)return console.log("Invalid displacement"),[];const m=[],c=[],l=[],p=u[0],d=u[1],b=u[2],h=u[3];for(let t=0;t<i;t++){const n=o.vec3.create();o.vec3.lerp(n,p.position,d.position,t/(i-1)),c.push(new a.Vertex(n,p.normal))}for(let t=0;t<i;t++){const n=o.vec3.create();o.vec3.lerp(n,h.position,b.position,t/(i-1)),l.push(new a.Vertex(n,p.normal))}for(let t=0;t<c.length;t++){const n=c[t],e=l[t];for(let t=0;t<i;t++){const r=o.vec3.create();o.vec3.lerp(r,n.position,e.position,t/(i-1)),null!=this.texture?m.push(new a.Vertex(r,p.normal,this.texture.placeholderColor,o.vec2.fromValues(0,0),this.texture.id)):m.push(new a.Vertex(r,p.normal))}}for(let t=0;t<this.dispInfo.numVerts();t++){const e=n.dispVerts[t+this.dispInfo.dispVertStart];o.vec3.scaleAndAdd(m[t].position,m[t].position,e.vec,e.dist)}return m}getFaceVertexes(t,n=!0){const e=t.readLump(r.LumpType.Planes).planes[this.face.planeNum].normal,s=t.readLump(r.LumpType.Vertexes),i=[];for(let n=this.face.firstEdge;n<this.face.firstEdge+this.face.numEdges;n++){const e=t.readLump(r.LumpType.SurfEdges).surfEdges[n],a=e<0,o=t.readLump(r.LumpType.Edges).edges[Math.abs(e)].getVertIndices(a);i.push(s.vertexes[o[0]]),i.push(s.vertexes[o[1]])}let u=[];return u=n?Array.from(new Set(i)).map(t=>null!=this.texture?new a.Vertex(t,e,this.texture.placeholderColor,o.vec2.fromValues(0,0),this.texture.id):new a.Vertex(t,e)):i.map(t=>new a.Vertex(t,e))}static verticesToBuffer(t){const n=[];return t.forEach(t=>{s.addRange(n,t.position),s.addRange(n,t.normal),s.addRange(n,t.texCoord),n.push(t.texIndex)}),n}}e.BSPFace=m},{"../../BSP/Lumps/LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js","../../BSP/Structs/Enums":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Structs\\Enums.js","../../Structs/Vertex":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Structs\\Vertex.js","../../Utils/AddRange":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Utils\\AddRange.js","./IRenderable":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\RenderObjects\\IRenderable.js","gl-matrix":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\node_modules\\gl-matrix\\dist\\gl-matrix.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\RenderObjects\\BSPObject.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./IRenderable"),r=t("../../BSP/Lumps/LumpType"),o=t("../Shaders/UniformLocs"),s=t("../../Utils/AddRange"),i=t("./BSPFace");e.BSPRenderObject=class{constructor(t,n){this.visibility=a.Visibility.Visible,this.initialized=!1,this.renderMode=WebGL2RenderingContext.TRIANGLES,this.vertexCount=0;const e=n.readLump(r.LumpType.Faces);this.vertices=[],this.faces=[],this.indices=[];let u=0;for(let t=0;t<e.faces.length;t++){const r=e.faces[t],o=new i.BSPFace(r,n);this.faces.push(o),o.calcIndices(u),s.addRange(this.vertices,o.getMesh()),o.visibility===a.Visibility.Visible&&s.addRange(this.indices,o.indices),u=null!=o.dispInfo?o.indices[o.indices.length-2]+1:o.indices[o.indices.length-1]+1}this.vertexCount=this.indices.length;const m=t.createBuffer(),c=t.createVertexArray(),l=t.createBuffer();null!=m?null!=c?null!=l?(this.VBO=m,this.VAO=c,this.EAO=l,t.bindBuffer(t.ARRAY_BUFFER,this.VBO),t.bufferData(t.ARRAY_BUFFER,new Float32Array(this.vertices),t.STATIC_DRAW),t.bindVertexArray(this.VAO),t.vertexAttribPointer(o.POSITION_ATTRIB_LOCATION,3,t.FLOAT,!1,36,0),t.enableVertexAttribArray(o.POSITION_ATTRIB_LOCATION),t.vertexAttribPointer(o.NORMAL_ATTRIB_LOCATION,3,t.FLOAT,!0,36,12),t.enableVertexAttribArray(o.NORMAL_ATTRIB_LOCATION),t.vertexAttribPointer(o.TEXCOORD_ATTRIB_LOCATION,2,t.FLOAT,!1,36,24),t.enableVertexAttribArray(o.TEXCOORD_ATTRIB_LOCATION),t.vertexAttribPointer(o.TEXINDEX_ATTRIB_LOCATION,1,t.FLOAT,!1,36,32),t.enableVertexAttribArray(o.TEXINDEX_ATTRIB_LOCATION),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.EAO),t.bufferData(t.ELEMENT_ARRAY_BUFFER,new Uint32Array(this.indices),t.STATIC_DRAW),this.initialized=!0,console.log("BSP Loaded")):console.log("Failed to generate EAO"):console.log("Failed to generate VAO"):console.log("Failed to generate VBO")}bind(t){}draw(t,n){this.initialized?this.visibility!==a.Visibility.Hidden&&(t.bindVertexArray(this.VAO),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.EAO),null==n?t.drawElements(this.renderMode,this.vertexCount,t.UNSIGNED_INT,0):t.drawElements(n,this.vertexCount,t.UNSIGNED_INT,0)):console.log("Cannot render object, not initialized")}}},{"../../BSP/Lumps/LumpType":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\Lumps\\LumpType.js","../../Utils/AddRange":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Utils\\AddRange.js","../Shaders/UniformLocs":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\Shaders\\UniformLocs.js","./BSPFace":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\RenderObjects\\BSPFace.js","./IRenderable":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\RenderObjects\\IRenderable.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\RenderObjects\\IRenderable.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),function(t){t[t.Visible=0]="Visible",t[t.Hidden=1]="Hidden"}(e.Visibility||(e.Visibility={}))},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\Shaders\\Shader.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});function a(t,n){const e=t.createShader(n.type);return t.shaderSource(e,n.source),t.compileShader(e),t.getShaderParameter(e,t.COMPILE_STATUS)?e:(console.log("----------Failed to compile shader----------\n"+n.source),console.log("Info log: "+t.getShaderInfoLog(e)),t.deleteShader(e),null)}e.Shader=class{},e.CreateShaderProgram=function(t,n){console.log("--Initializing Shaders--"),console.log("   Number of shaders: "+n.length);const e=[];n.forEach(n=>{const r=a(t,n);null!=r&&e.push(r)});const r=t.createProgram();return e.forEach(n=>{t.attachShader(r,n)}),t.linkProgram(r),t.getProgramParameter(r,t.LINK_STATUS)?r:(console.log("Unable to initialize shader program: "+t.getProgramInfoLog(r)),null)},e.LoadShader=a},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\Shaders\\ShaderSource.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});class a{constructor(t,n){this.source=t,this.type=n}}e.ShaderSource=a,e.VertShader=new a("#version 300 es\n\nlayout (location = 0) in vec4 a_position;\nlayout (location = 1) in vec4 a_normal;\nlayout (location = 2) in vec2 a_texCoord;\nlayout (location = 3) in float a_texIndex;\n\nuniform mat4 u_model_mat;\nuniform mat4 u_view_mat;\nuniform mat4 u_projection_mat;\n\nout highp vec4 v_norm;\nout highp vec2 v_uv;\nflat out int v_texIndex;\n\nvoid main() {\n\tgl_Position = u_projection_mat * u_view_mat * u_model_mat * a_position;\n\n\t//temp\n\tgl_PointSize = 20.0;\n\n\tv_norm = a_normal;\n\tv_uv = a_texCoord;\n\tv_texIndex = int(a_texIndex);\n\n}",WebGLRenderingContext.VERTEX_SHADER),e.FragShader=new a("#version 300 es\nprecision mediump float;\n\nuniform highp sampler2DArray u_texture_array;\n\nin highp vec4 v_norm;\nin highp vec2 v_uv;\nflat in int v_texIndex;\n\nout vec4 fragColor;\n\nvoid main() {\n\tvec4 color = vec4(0.2, 0.2, 0.2, 1.0);\n\tvec4 ambientColor = vec4(0.1, 0.1, 0.1, 1.0);\n\n\tvec4 lightDir = vec4(0.707107, 0.707107, 0, 1.0);\n\n\tfloat intensity = clamp(dot(v_norm, lightDir), 0.0, 1.0);\n\tif (intensity > 0.0) {\n\t\tcolor += (ambientColor * intensity);\n\t}\n\n\tcolor = clamp(color, 0.0, 1.0);\n\n\t// z index of sampler2DArray is the layer\n\tfragColor = texture(u_texture_array, vec3(v_uv, v_texIndex)) + color;\n}",WebGLRenderingContext.FRAGMENT_SHADER)},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\Shaders\\UniformLocs.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.POSITION_ATTRIB_LOCATION=0,e.NORMAL_ATTRIB_LOCATION=1,e.TEXCOORD_ATTRIB_LOCATION=2,e.TEXINDEX_ATTRIB_LOCATION=3},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\UniformLocations.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.UniformLocations=class{constructor(t,n){this.uModelMatLocation=t.getUniformLocation(n,"u_model_mat"),this.uViewMatLocation=t.getUniformLocation(n,"u_view_mat"),this.uProjectionMatrixLocation=t.getUniformLocation(n,"u_projection_mat"),this.uTextureArrayLocation=t.getUniformLocation(n,"u_sampler")}}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Structs\\Vertex.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("gl-matrix");e.Vertex=class{constructor(t,n=a.vec3.create(),e=a.vec4.create(),r=a.vec2.fromValues(0,1),o=255){this.position=t,this.normal=n,this.fallbackColor=e,this.texCoord=r,this.texIndex=o}}},{"gl-matrix":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\node_modules\\gl-matrix\\dist\\gl-matrix.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Utils\\AddRange.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.addRange=function(t,n){n.forEach(n=>{t.push(n)})}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Utils\\KeyPress.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),function(t){t.A="A",t.B="B",t.C="C",t.D="D",t.E="E",t.F="F",t.G="G",t.H="H",t.I="I",t.J="J",t.K="K",t.L="L",t.M="M",t.N="N",t.O="O",t.P="P",t.Q="Q",t.R="R",t.S="S",t.T="T",t.U="U",t.V="V",t.W="W",t.X="X",t.Y="Y",t.Z="Z",t.Escape="Escape"}(e.Key||(e.Key={})),function(t){t.Shift="Shift"}(e.KeyModifier||(e.KeyModifier={})),function(t){t[t.Keyup=0]="Keyup",t[t.Keydown=1]="Keydown"}(e.KeyState||(e.KeyState={}));e.KeyPress=class{constructor(t,n,e){this.key=t,this.modifier=e,this.state=n}}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Utils\\LimitAngle.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.limitAngle=function(t,n,e){return t<n?n:t>e?e:t}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Utils\\WrapAngle.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.wrapAngle=function(t){for(;t>=360;)t-=360;for(;t<0;)t+=360;return t}},{}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\main.js":[function(t,n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const a=t("./Rendering/CoreEngine"),r=t("./BSP/BSP"),o=t("./Rendering/RenderObjects/BSPObject");window.initWebGL=function(){new s};class s{constructor(){const t=document.getElementById("canvas");t?(this.gl=t.getContext("webgl2"),this.gl?(console.log("WebGL Version: "+this.gl.VERSION),console.log("WebGL Shader Language Version: "+this.gl.SHADING_LANGUAGE_VERSION),this.renderer=new a.CoreEngine(this.gl),this.renderer.main(),this.setupBtnListeners()):alert("Unable to initialize WebGL2. Your browser may not support it.")):alert("Could not find canvas")}setupBtnListeners(){const t=document.getElementById("openBtn");if(null==t)return void console.log("Open button was null");t.addEventListener("click",this.openFileBtnCallback.bind(this),!1);const n=document.getElementById("fileDialog");n.value="",n&&(null!=n?n.addEventListener("change",()=>{if(null==n.files)return void console.log("selected files were null");const t=n.files[0];if(null!=t)if(t.name.match(/.*\.(bsp)$/gm)){const n=new FileReader;n.onload=this.readBSP.bind(this),n.readAsArrayBuffer(t)}else console.log("Only BSP files are supported")},!1):console.log("fileDialog was null"))}openFileBtnCallback(){const t=document.getElementById("fileDialog");null!=t?t.click():console.log("fileDialog was null")}readBSP(t){if(null==t.target)throw new Error("BSP Read Error");const n=new r.BSP(t.target.result);null!=this.gl&&(this.renderer.clearRenderObjects(),this.renderer.addRenderableObject(new o.BSPRenderObject(this.gl,n)),this.renderer.renderFrame=!0)}}},{"./BSP/BSP":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\BSP\\BSP.js","./Rendering/CoreEngine":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\CoreEngine.js","./Rendering/RenderObjects/BSPObject":"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\Rendering\\RenderObjects\\BSPObject.js"}],"C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\node_modules\\gl-matrix\\dist\\gl-matrix.js":[function(require,module,exports){!function(t,n){if("object"==typeof exports&&"object"==typeof module)module.exports=n();else if("function"==typeof define&&define.amd)define([],n);else{var e=n();for(var a in e)("object"==typeof exports?exports:t)[a]=e[a]}}("undefined"!=typeof self?self:this,function(){return function(t){var n={};function e(a){if(n[a])return n[a].exports;var r=n[a]={i:a,l:!1,exports:{}};return t[a].call(r.exports,r,r.exports,e),r.l=!0,r.exports}return e.m=t,e.c=n,e.d=function(t,n,a){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:a})},e.r=function(t){Object.defineProperty(t,"__esModule",{value:!0})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s="./src/gl-matrix.js")}({"./src/gl-matrix.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.vec4 = exports.vec3 = exports.vec2 = exports.quat2 = exports.quat = exports.mat4 = exports.mat3 = exports.mat2d = exports.mat2 = exports.glMatrix = undefined;\n\nvar _common = __webpack_require__(/*! ./gl-matrix/common.js */ "./src/gl-matrix/common.js");\n\nvar glMatrix = _interopRequireWildcard(_common);\n\nvar _mat = __webpack_require__(/*! ./gl-matrix/mat2.js */ "./src/gl-matrix/mat2.js");\n\nvar mat2 = _interopRequireWildcard(_mat);\n\nvar _mat2d = __webpack_require__(/*! ./gl-matrix/mat2d.js */ "./src/gl-matrix/mat2d.js");\n\nvar mat2d = _interopRequireWildcard(_mat2d);\n\nvar _mat2 = __webpack_require__(/*! ./gl-matrix/mat3.js */ "./src/gl-matrix/mat3.js");\n\nvar mat3 = _interopRequireWildcard(_mat2);\n\nvar _mat3 = __webpack_require__(/*! ./gl-matrix/mat4.js */ "./src/gl-matrix/mat4.js");\n\nvar mat4 = _interopRequireWildcard(_mat3);\n\nvar _quat = __webpack_require__(/*! ./gl-matrix/quat.js */ "./src/gl-matrix/quat.js");\n\nvar quat = _interopRequireWildcard(_quat);\n\nvar _quat2 = __webpack_require__(/*! ./gl-matrix/quat2.js */ "./src/gl-matrix/quat2.js");\n\nvar quat2 = _interopRequireWildcard(_quat2);\n\nvar _vec = __webpack_require__(/*! ./gl-matrix/vec2.js */ "./src/gl-matrix/vec2.js");\n\nvar vec2 = _interopRequireWildcard(_vec);\n\nvar _vec2 = __webpack_require__(/*! ./gl-matrix/vec3.js */ "./src/gl-matrix/vec3.js");\n\nvar vec3 = _interopRequireWildcard(_vec2);\n\nvar _vec3 = __webpack_require__(/*! ./gl-matrix/vec4.js */ "./src/gl-matrix/vec4.js");\n\nvar vec4 = _interopRequireWildcard(_vec3);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nexports.glMatrix = glMatrix;\nexports.mat2 = mat2;\nexports.mat2d = mat2d;\nexports.mat3 = mat3;\nexports.mat4 = mat4;\nexports.quat = quat;\nexports.quat2 = quat2;\nexports.vec2 = vec2;\nexports.vec3 = vec3;\nexports.vec4 = vec4;\n\n//# sourceURL=webpack:///./src/gl-matrix.js?')},"./src/gl-matrix/common.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setMatrixArrayType = setMatrixArrayType;\nexports.toRadian = toRadian;\nexports.equals = equals;\n/**\n * Common utilities\n * @module glMatrix\n */\n\n// Configuration Constants\nvar EPSILON = exports.EPSILON = 0.000001;\nvar ARRAY_TYPE = exports.ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nvar RANDOM = exports.RANDOM = Math.random;\n\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Type} type Array type, such as Float32Array or Array\n */\nfunction setMatrixArrayType(type) {\n  exports.ARRAY_TYPE = ARRAY_TYPE = type;\n}\n\nvar degree = Math.PI / 180;\n\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\nfunction toRadian(a) {\n  return a * degree;\n}\n\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\nfunction equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\n\n//# sourceURL=webpack:///./src/gl-matrix/common.js?")},"./src/gl-matrix/mat2.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sub = exports.mul = undefined;\nexports.create = create;\nexports.clone = clone;\nexports.copy = copy;\nexports.identity = identity;\nexports.fromValues = fromValues;\nexports.set = set;\nexports.transpose = transpose;\nexports.invert = invert;\nexports.adjoint = adjoint;\nexports.determinant = determinant;\nexports.multiply = multiply;\nexports.rotate = rotate;\nexports.scale = scale;\nexports.fromRotation = fromRotation;\nexports.fromScaling = fromScaling;\nexports.str = str;\nexports.frob = frob;\nexports.LDU = LDU;\nexports.add = add;\nexports.subtract = subtract;\nexports.exactEquals = exactEquals;\nexports.equals = equals;\nexports.multiplyScalar = multiplyScalar;\nexports.multiplyScalarAndAdd = multiplyScalarAndAdd;\n\nvar _common = __webpack_require__(/*! ./common.js */ \"./src/gl-matrix/common.js\");\n\nvar glMatrix = _interopRequireWildcard(_common);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * 2x2 Matrix\n * @module mat2\n */\n\n/**\n * Creates a new identity mat2\n *\n * @returns {mat2} a new 2x2 matrix\n */\nfunction create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Creates a new mat2 initialized with values from an existing matrix\n *\n * @param {mat2} a matrix to clone\n * @returns {mat2} a new 2x2 matrix\n */\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Copy the values from one mat2 to another\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Set a mat2 to the identity matrix\n *\n * @param {mat2} out the receiving matrix\n * @returns {mat2} out\n */\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Create a new mat2 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out A new 2x2 matrix\n */\nfunction fromValues(m00, m01, m10, m11) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n\n/**\n * Set the components of a mat2 to the given values\n *\n * @param {mat2} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out\n */\nfunction set(out, m00, m01, m10, m11) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n\n/**\n * Transpose the values of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache\n  // some values\n  if (out === a) {\n    var a1 = a[1];\n    out[1] = a[2];\n    out[2] = a1;\n  } else {\n    out[0] = a[0];\n    out[1] = a[2];\n    out[2] = a[1];\n    out[3] = a[3];\n  }\n\n  return out;\n}\n\n/**\n * Inverts a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nfunction invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n\n  // Calculate the determinant\n  var det = a0 * a3 - a2 * a1;\n\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n\n  out[0] = a3 * det;\n  out[1] = -a1 * det;\n  out[2] = -a2 * det;\n  out[3] = a0 * det;\n\n  return out;\n}\n\n/**\n * Calculates the adjugate of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nfunction adjoint(out, a) {\n  // Caching this value is nessecary if out == a\n  var a0 = a[0];\n  out[0] = a[3];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a0;\n\n  return out;\n}\n\n/**\n * Calculates the determinant of a mat2\n *\n * @param {mat2} a the source matrix\n * @returns {Number} determinant of a\n */\nfunction determinant(a) {\n  return a[0] * a[3] - a[2] * a[1];\n}\n\n/**\n * Multiplies two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @returns {mat2} out\n */\nfunction multiply(out, a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = a0 * b0 + a2 * b1;\n  out[1] = a1 * b0 + a3 * b1;\n  out[2] = a0 * b2 + a2 * b3;\n  out[3] = a1 * b2 + a3 * b3;\n  return out;\n}\n\n/**\n * Rotates a mat2 by the given angle\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\nfunction rotate(out, a, rad) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = a0 * c + a2 * s;\n  out[1] = a1 * c + a3 * s;\n  out[2] = a0 * -s + a2 * c;\n  out[3] = a1 * -s + a3 * c;\n  return out;\n}\n\n/**\n * Scales the mat2 by the dimensions in the given vec2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat2} out\n **/\nfunction scale(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0 * v0;\n  out[1] = a1 * v0;\n  out[2] = a2 * v1;\n  out[3] = a3 * v1;\n  return out;\n}\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.rotate(dest, dest, rad);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\nfunction fromRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = -s;\n  out[3] = c;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.scale(dest, dest, vec);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {vec2} v Scaling vector\n * @returns {mat2} out\n */\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = v[1];\n  return out;\n}\n\n/**\n * Returns a string representation of a mat2\n *\n * @param {mat2} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nfunction str(a) {\n  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n}\n\n/**\n * Returns Frobenius norm of a mat2\n *\n * @param {mat2} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nfunction frob(a) {\n  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));\n}\n\n/**\n * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix\n * @param {mat2} L the lower triangular matrix\n * @param {mat2} D the diagonal matrix\n * @param {mat2} U the upper triangular matrix\n * @param {mat2} a the input matrix to factorize\n */\n\nfunction LDU(L, D, U, a) {\n  L[2] = a[2] / a[0];\n  U[0] = a[0];\n  U[1] = a[1];\n  U[3] = a[3] - L[2] * U[1];\n  return [L, D, U];\n}\n\n/**\n * Adds two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @returns {mat2} out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @returns {mat2} out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat2} a The first matrix.\n * @param {mat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat2} a The first matrix.\n * @param {mat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat2} out\n */\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n\n/**\n * Adds two mat2's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat2} out the receiving vector\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat2} out\n */\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n\n/**\n * Alias for {@link mat2.multiply}\n * @function\n */\nvar mul = exports.mul = multiply;\n\n/**\n * Alias for {@link mat2.subtract}\n * @function\n */\nvar sub = exports.sub = subtract;\n\n//# sourceURL=webpack:///./src/gl-matrix/mat2.js?")},"./src/gl-matrix/mat2d.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sub = exports.mul = undefined;\nexports.create = create;\nexports.clone = clone;\nexports.copy = copy;\nexports.identity = identity;\nexports.fromValues = fromValues;\nexports.set = set;\nexports.invert = invert;\nexports.determinant = determinant;\nexports.multiply = multiply;\nexports.rotate = rotate;\nexports.scale = scale;\nexports.translate = translate;\nexports.fromRotation = fromRotation;\nexports.fromScaling = fromScaling;\nexports.fromTranslation = fromTranslation;\nexports.str = str;\nexports.frob = frob;\nexports.add = add;\nexports.subtract = subtract;\nexports.multiplyScalar = multiplyScalar;\nexports.multiplyScalarAndAdd = multiplyScalarAndAdd;\nexports.exactEquals = exactEquals;\nexports.equals = equals;\n\nvar _common = __webpack_require__(/*! ./common.js */ \"./src/gl-matrix/common.js\");\n\nvar glMatrix = _interopRequireWildcard(_common);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * 2x3 Matrix\n * @module mat2d\n *\n * @description\n * A mat2d contains six elements defined as:\n * <pre>\n * [a, c, tx,\n *  b, d, ty]\n * </pre>\n * This is a short form for the 3x3 matrix:\n * <pre>\n * [a, c, tx,\n *  b, d, ty,\n *  0, 0, 1]\n * </pre>\n * The last row is ignored so the array is shorter and operations are faster.\n */\n\n/**\n * Creates a new identity mat2d\n *\n * @returns {mat2d} a new 2x3 matrix\n */\nfunction create() {\n  var out = new glMatrix.ARRAY_TYPE(6);\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n\n/**\n * Creates a new mat2d initialized with values from an existing matrix\n *\n * @param {mat2d} a matrix to clone\n * @returns {mat2d} a new 2x3 matrix\n */\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(6);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  return out;\n}\n\n/**\n * Copy the values from one mat2d to another\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the source matrix\n * @returns {mat2d} out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  return out;\n}\n\n/**\n * Set a mat2d to the identity matrix\n *\n * @param {mat2d} out the receiving matrix\n * @returns {mat2d} out\n */\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n\n/**\n * Create a new mat2d with the given values\n *\n * @param {Number} a Component A (index 0)\n * @param {Number} b Component B (index 1)\n * @param {Number} c Component C (index 2)\n * @param {Number} d Component D (index 3)\n * @param {Number} tx Component TX (index 4)\n * @param {Number} ty Component TY (index 5)\n * @returns {mat2d} A new mat2d\n */\nfunction fromValues(a, b, c, d, tx, ty) {\n  var out = new glMatrix.ARRAY_TYPE(6);\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n  out[4] = tx;\n  out[5] = ty;\n  return out;\n}\n\n/**\n * Set the components of a mat2d to the given values\n *\n * @param {mat2d} out the receiving matrix\n * @param {Number} a Component A (index 0)\n * @param {Number} b Component B (index 1)\n * @param {Number} c Component C (index 2)\n * @param {Number} d Component D (index 3)\n * @param {Number} tx Component TX (index 4)\n * @param {Number} ty Component TY (index 5)\n * @returns {mat2d} out\n */\nfunction set(out, a, b, c, d, tx, ty) {\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n  out[4] = tx;\n  out[5] = ty;\n  return out;\n}\n\n/**\n * Inverts a mat2d\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the source matrix\n * @returns {mat2d} out\n */\nfunction invert(out, a) {\n  var aa = a[0],\n      ab = a[1],\n      ac = a[2],\n      ad = a[3];\n  var atx = a[4],\n      aty = a[5];\n\n  var det = aa * ad - ab * ac;\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n\n  out[0] = ad * det;\n  out[1] = -ab * det;\n  out[2] = -ac * det;\n  out[3] = aa * det;\n  out[4] = (ac * aty - ad * atx) * det;\n  out[5] = (ab * atx - aa * aty) * det;\n  return out;\n}\n\n/**\n * Calculates the determinant of a mat2d\n *\n * @param {mat2d} a the source matrix\n * @returns {Number} determinant of a\n */\nfunction determinant(a) {\n  return a[0] * a[3] - a[1] * a[2];\n}\n\n/**\n * Multiplies two mat2d's\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @returns {mat2d} out\n */\nfunction multiply(out, a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5];\n  out[0] = a0 * b0 + a2 * b1;\n  out[1] = a1 * b0 + a3 * b1;\n  out[2] = a0 * b2 + a2 * b3;\n  out[3] = a1 * b2 + a3 * b3;\n  out[4] = a0 * b4 + a2 * b5 + a4;\n  out[5] = a1 * b4 + a3 * b5 + a5;\n  return out;\n}\n\n/**\n * Rotates a mat2d by the given angle\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2d} out\n */\nfunction rotate(out, a, rad) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = a0 * c + a2 * s;\n  out[1] = a1 * c + a3 * s;\n  out[2] = a0 * -s + a2 * c;\n  out[3] = a1 * -s + a3 * c;\n  out[4] = a4;\n  out[5] = a5;\n  return out;\n}\n\n/**\n * Scales the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to translate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat2d} out\n **/\nfunction scale(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0 * v0;\n  out[1] = a1 * v0;\n  out[2] = a2 * v1;\n  out[3] = a3 * v1;\n  out[4] = a4;\n  out[5] = a5;\n  return out;\n}\n\n/**\n * Translates the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to translate\n * @param {vec2} v the vec2 to translate the matrix by\n * @returns {mat2d} out\n **/\nfunction translate(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0;\n  out[1] = a1;\n  out[2] = a2;\n  out[3] = a3;\n  out[4] = a0 * v0 + a2 * v1 + a4;\n  out[5] = a1 * v0 + a3 * v1 + a5;\n  return out;\n}\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.rotate(dest, dest, rad);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2d} out\n */\nfunction fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = -s;\n  out[3] = c;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.scale(dest, dest, vec);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {vec2} v Scaling vector\n * @returns {mat2d} out\n */\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = v[1];\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.translate(dest, dest, vec);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {vec2} v Translation vector\n * @returns {mat2d} out\n */\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = v[0];\n  out[5] = v[1];\n  return out;\n}\n\n/**\n * Returns a string representation of a mat2d\n *\n * @param {mat2d} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nfunction str(a) {\n  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';\n}\n\n/**\n * Returns Frobenius norm of a mat2d\n *\n * @param {mat2d} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nfunction frob(a) {\n  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);\n}\n\n/**\n * Adds two mat2d's\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @returns {mat2d} out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @returns {mat2d} out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  return out;\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat2d} out\n */\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  return out;\n}\n\n/**\n * Adds two mat2d's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat2d} out the receiving vector\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat2d} out\n */\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  return out;\n}\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat2d} a The first matrix.\n * @param {mat2d} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];\n}\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat2d} a The first matrix.\n * @param {mat2d} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));\n}\n\n/**\n * Alias for {@link mat2d.multiply}\n * @function\n */\nvar mul = exports.mul = multiply;\n\n/**\n * Alias for {@link mat2d.subtract}\n * @function\n */\nvar sub = exports.sub = subtract;\n\n//# sourceURL=webpack:///./src/gl-matrix/mat2d.js?")},"./src/gl-matrix/mat3.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sub = exports.mul = undefined;\nexports.create = create;\nexports.fromMat4 = fromMat4;\nexports.clone = clone;\nexports.copy = copy;\nexports.fromValues = fromValues;\nexports.set = set;\nexports.identity = identity;\nexports.transpose = transpose;\nexports.invert = invert;\nexports.adjoint = adjoint;\nexports.determinant = determinant;\nexports.multiply = multiply;\nexports.translate = translate;\nexports.rotate = rotate;\nexports.scale = scale;\nexports.fromTranslation = fromTranslation;\nexports.fromRotation = fromRotation;\nexports.fromScaling = fromScaling;\nexports.fromMat2d = fromMat2d;\nexports.fromQuat = fromQuat;\nexports.normalFromMat4 = normalFromMat4;\nexports.projection = projection;\nexports.str = str;\nexports.frob = frob;\nexports.add = add;\nexports.subtract = subtract;\nexports.multiplyScalar = multiplyScalar;\nexports.multiplyScalarAndAdd = multiplyScalarAndAdd;\nexports.exactEquals = exactEquals;\nexports.equals = equals;\n\nvar _common = __webpack_require__(/*! ./common.js */ \"./src/gl-matrix/common.js\");\n\nvar glMatrix = _interopRequireWildcard(_common);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * 3x3 Matrix\n * @module mat3\n */\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\nfunction create() {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {mat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\nfunction fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {mat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n\n/**\n * Create a new mat3 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} A new mat3\n */\nfunction fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} out\n */\nfunction set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nfunction invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n\n  var b01 = a22 * a11 - a12 * a21;\n  var b11 = -a22 * a10 + a12 * a20;\n  var b21 = a21 * a10 - a11 * a20;\n\n  // Calculate the determinant\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nfunction adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n\n  out[0] = a11 * a22 - a12 * a21;\n  out[1] = a02 * a21 - a01 * a22;\n  out[2] = a01 * a12 - a02 * a11;\n  out[3] = a12 * a20 - a10 * a22;\n  out[4] = a00 * a22 - a02 * a20;\n  out[5] = a02 * a10 - a00 * a12;\n  out[6] = a10 * a21 - a11 * a20;\n  out[7] = a01 * a20 - a00 * a21;\n  out[8] = a00 * a11 - a01 * a10;\n  return out;\n}\n\n/**\n * Calculates the determinant of a mat3\n *\n * @param {mat3} a the source matrix\n * @returns {Number} determinant of a\n */\nfunction determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nfunction multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n\n  var b00 = b[0],\n      b01 = b[1],\n      b02 = b[2];\n  var b10 = b[3],\n      b11 = b[4],\n      b12 = b[5];\n  var b20 = b[6],\n      b21 = b[7],\n      b22 = b[8];\n\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to translate\n * @param {vec2} v vector to translate by\n * @returns {mat3} out\n */\nfunction translate(out, a, v) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      x = v[0],\n      y = v[1];\n\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nfunction rotate(out, a, rad) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n};\n\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\nfunction scale(out, a, v) {\n  var x = v[0],\n      y = v[1];\n\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.translate(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {vec2} v Translation vector\n * @returns {mat3} out\n */\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = v[0];\n  out[7] = v[1];\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.rotate(dest, dest, rad);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nfunction fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n\n  out[3] = -s;\n  out[4] = c;\n  out[5] = 0;\n\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.scale(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {vec2} v Scaling vector\n * @returns {mat3} out\n */\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat2d} a the matrix to copy\n * @returns {mat3} out\n **/\nfunction fromMat2d(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = 0;\n\n  out[3] = a[2];\n  out[4] = a[3];\n  out[5] = 0;\n\n  out[6] = a[4];\n  out[7] = a[5];\n  out[8] = 1;\n  return out;\n}\n\n/**\n* Calculates a 3x3 matrix from the given quaternion\n*\n* @param {mat3} out mat3 receiving operation result\n* @param {quat} q Quaternion to create matrix from\n*\n* @returns {mat3} out\n*/\nfunction fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n\n  return out;\n}\n\n/**\n* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n*\n* @param {mat3} out mat3 receiving operation result\n* @param {mat4} a Mat4 to derive the normal matrix from\n*\n* @returns {mat3} out\n*/\nfunction normalFromMat4(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32;\n\n  // Calculate the determinant\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n\n  return out;\n}\n\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\nfunction projection(out, width, height) {\n  out[0] = 2 / width;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -2 / height;\n  out[5] = 0;\n  out[6] = -1;\n  out[7] = 1;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Returns a string representation of a mat3\n *\n * @param {mat3} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nfunction str(a) {\n  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';\n}\n\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {mat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nfunction frob(a) {\n  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));\n}\n\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n\n/**\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat3} out the receiving vector\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat3} out\n */\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  return out;\n}\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat3} a The first matrix.\n * @param {mat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n}\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat3} a The first matrix.\n * @param {mat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7],\n      a8 = a[8];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7],\n      b8 = b[8];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));\n}\n\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\nvar mul = exports.mul = multiply;\n\n/**\n * Alias for {@link mat3.subtract}\n * @function\n */\nvar sub = exports.sub = subtract;\n\n//# sourceURL=webpack:///./src/gl-matrix/mat3.js?")},"./src/gl-matrix/mat4.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sub = exports.mul = undefined;\nexports.create = create;\nexports.clone = clone;\nexports.copy = copy;\nexports.fromValues = fromValues;\nexports.set = set;\nexports.identity = identity;\nexports.transpose = transpose;\nexports.invert = invert;\nexports.adjoint = adjoint;\nexports.determinant = determinant;\nexports.multiply = multiply;\nexports.translate = translate;\nexports.scale = scale;\nexports.rotate = rotate;\nexports.rotateX = rotateX;\nexports.rotateY = rotateY;\nexports.rotateZ = rotateZ;\nexports.fromTranslation = fromTranslation;\nexports.fromScaling = fromScaling;\nexports.fromRotation = fromRotation;\nexports.fromXRotation = fromXRotation;\nexports.fromYRotation = fromYRotation;\nexports.fromZRotation = fromZRotation;\nexports.fromRotationTranslation = fromRotationTranslation;\nexports.fromQuat2 = fromQuat2;\nexports.getTranslation = getTranslation;\nexports.getScaling = getScaling;\nexports.getRotation = getRotation;\nexports.fromRotationTranslationScale = fromRotationTranslationScale;\nexports.fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin;\nexports.fromQuat = fromQuat;\nexports.frustum = frustum;\nexports.perspective = perspective;\nexports.perspectiveFromFieldOfView = perspectiveFromFieldOfView;\nexports.ortho = ortho;\nexports.lookAt = lookAt;\nexports.targetTo = targetTo;\nexports.str = str;\nexports.frob = frob;\nexports.add = add;\nexports.subtract = subtract;\nexports.multiplyScalar = multiplyScalar;\nexports.multiplyScalarAndAdd = multiplyScalarAndAdd;\nexports.exactEquals = exactEquals;\nexports.equals = equals;\n\nvar _common = __webpack_require__(/*! ./common.js */ \"./src/gl-matrix/common.js\");\n\nvar glMatrix = _interopRequireWildcard(_common);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\nfunction create() {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {mat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\nfunction fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\nfunction set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nfunction invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32;\n\n  // Calculate the determinant\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n\n  return out;\n}\n\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nfunction adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n\n/**\n * Calculates the determinant of a mat4\n *\n * @param {mat4} a the source matrix\n * @returns {Number} determinant of a\n */\nfunction determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32;\n\n  // Calculate the determinant\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nfunction multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n\n  // Cache only the current line of the second matrix\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n  b0 = b[4];b1 = b[5];b2 = b[6];b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n  b0 = b[8];b1 = b[9];b2 = b[10];b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n  b0 = b[12];b1 = b[13];b2 = b[14];b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to translate\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */\nfunction translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00 = void 0,\n      a01 = void 0,\n      a02 = void 0,\n      a03 = void 0;\n  var a10 = void 0,\n      a11 = void 0,\n      a12 = void 0,\n      a13 = void 0;\n  var a20 = void 0,\n      a21 = void 0,\n      a22 = void 0,\n      a23 = void 0;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];\n    a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];\n    a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];\n\n    out[0] = a00;out[1] = a01;out[2] = a02;out[3] = a03;\n    out[4] = a10;out[5] = a11;out[6] = a12;out[7] = a13;\n    out[8] = a20;out[9] = a21;out[10] = a22;out[11] = a23;\n\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\nfunction scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {vec3} axis the axis to rotate around\n * @returns {mat4} out\n */\nfunction rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.sqrt(x * x + y * y + z * z);\n  var s = void 0,\n      c = void 0,\n      t = void 0;\n  var a00 = void 0,\n      a01 = void 0,\n      a02 = void 0,\n      a03 = void 0;\n  var a10 = void 0,\n      a11 = void 0,\n      a12 = void 0,\n      a13 = void 0;\n  var a20 = void 0,\n      a21 = void 0,\n      a22 = void 0,\n      a23 = void 0;\n  var b00 = void 0,\n      b01 = void 0,\n      b02 = void 0;\n  var b10 = void 0,\n      b11 = void 0,\n      b12 = void 0;\n  var b20 = void 0,\n      b21 = void 0,\n      b22 = void 0;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n\n  a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];\n  a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];\n  a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];\n\n  // Construct the elements of the rotation matrix\n  b00 = x * x * t + c;b01 = y * x * t + z * s;b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;b11 = y * y * t + c;b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;b21 = y * z * t - x * s;b22 = z * z * t + c;\n\n  // Perform rotation-specific matrix multiplication\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n  return out;\n}\n\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nfunction rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  // Perform axis-specific matrix multiplication\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nfunction rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  // Perform axis-specific matrix multiplication\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nfunction rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  // Perform axis-specific matrix multiplication\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {vec3} v Translation vector\n * @returns {mat4} out\n */\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {vec3} v Scaling vector\n * @returns {mat4} out\n */\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {vec3} axis the axis to rotate around\n * @returns {mat4} out\n */\nfunction fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.sqrt(x * x + y * y + z * z);\n  var s = void 0,\n      c = void 0,\n      t = void 0;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n\n  // Perform rotation-specific matrix multiplication\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nfunction fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n\n  // Perform axis-specific matrix multiplication\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nfunction fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n\n  // Perform axis-specific matrix multiplication\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nfunction fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n\n  // Perform axis-specific matrix multiplication\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @returns {mat4} out\n */\nfunction fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n\n  return out;\n}\n\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {quat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\nfunction fromQuat2(out, a) {\n  var translation = new glMatrix.ARRAY_TYPE(3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw;\n  //Only scale if it makes sense\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\nfunction getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n\n  return out;\n}\n\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\nfunction getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n\n  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);\n  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);\n  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);\n\n  return out;\n}\n\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {mat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\nfunction getRotation(out, mat) {\n  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n  var trace = mat[0] + mat[5] + mat[10];\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (mat[6] - mat[9]) / S;\n    out[1] = (mat[8] - mat[2]) / S;\n    out[2] = (mat[1] - mat[4]) / S;\n  } else if (mat[0] > mat[5] && mat[0] > mat[10]) {\n    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;\n    out[3] = (mat[6] - mat[9]) / S;\n    out[0] = 0.25 * S;\n    out[1] = (mat[1] + mat[4]) / S;\n    out[2] = (mat[8] + mat[2]) / S;\n  } else if (mat[5] > mat[10]) {\n    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;\n    out[3] = (mat[8] - mat[2]) / S;\n    out[0] = (mat[1] + mat[4]) / S;\n    out[1] = 0.25 * S;\n    out[2] = (mat[6] + mat[9]) / S;\n  } else {\n    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;\n    out[3] = (mat[1] - mat[4]) / S;\n    out[0] = (mat[8] + mat[2]) / S;\n    out[1] = (mat[6] + mat[9]) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @param {vec3} s Scaling vector\n * @returns {mat4} out\n */\nfunction fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n\n  return out;\n}\n\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @param {vec3} s Scaling vector\n * @param {vec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\nfunction fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n\n  return out;\n}\n\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\nfunction fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n\n  return out;\n}\n\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\nfunction frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n\n/**\n * Generates a perspective projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nfunction perspective(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2);\n  var nf = 1 / (near - far);\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 2 * far * near * nf;\n  out[15] = 0;\n  return out;\n}\n\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nfunction perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n\n/**\n * Generates a orthogonal projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nfunction ortho(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {vec3} eye Position of the viewer\n * @param {vec3} center Point the viewer is looking at\n * @param {vec3} up vec3 pointing up\n * @returns {mat4} out\n */\nfunction lookAt(out, eye, center, up) {\n  var x0 = void 0,\n      x1 = void 0,\n      x2 = void 0,\n      y0 = void 0,\n      y1 = void 0,\n      y2 = void 0,\n      z0 = void 0,\n      z1 = void 0,\n      z2 = void 0,\n      len = void 0;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n\n  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n\n  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n\n  return out;\n}\n\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {vec3} eye Position of the viewer\n * @param {vec3} center Point the viewer is looking at\n * @param {vec3} up vec3 pointing up\n * @returns {mat4} out\n */\nfunction targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n};\n\n/**\n * Returns a string representation of a mat4\n *\n * @param {mat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nfunction str(a) {\n  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';\n}\n\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {mat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nfunction frob(a) {\n  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));\n}\n\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat4} a The first matrix.\n * @param {mat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat4} a The first matrix.\n * @param {mat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\nvar mul = exports.mul = multiply;\n\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\nvar sub = exports.sub = subtract;\n\n//# sourceURL=webpack:///./src/gl-matrix/mat4.js?")},"./src/gl-matrix/quat.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.setAxes = exports.sqlerp = exports.rotationTo = exports.equals = exports.exactEquals = exports.normalize = exports.sqrLen = exports.squaredLength = exports.len = exports.length = exports.lerp = exports.dot = exports.scale = exports.mul = exports.add = exports.set = exports.copy = exports.fromValues = exports.clone = undefined;\nexports.create = create;\nexports.identity = identity;\nexports.setAxisAngle = setAxisAngle;\nexports.getAxisAngle = getAxisAngle;\nexports.multiply = multiply;\nexports.rotateX = rotateX;\nexports.rotateY = rotateY;\nexports.rotateZ = rotateZ;\nexports.calculateW = calculateW;\nexports.slerp = slerp;\nexports.invert = invert;\nexports.conjugate = conjugate;\nexports.fromMat3 = fromMat3;\nexports.fromEuler = fromEuler;\nexports.str = str;\n\nvar _common = __webpack_require__(/*! ./common.js */ "./src/gl-matrix/common.js");\n\nvar glMatrix = _interopRequireWildcard(_common);\n\nvar _mat = __webpack_require__(/*! ./mat3.js */ "./src/gl-matrix/mat3.js");\n\nvar mat3 = _interopRequireWildcard(_mat);\n\nvar _vec = __webpack_require__(/*! ./vec3.js */ "./src/gl-matrix/vec3.js");\n\nvar vec3 = _interopRequireWildcard(_vec);\n\nvar _vec2 = __webpack_require__(/*! ./vec4.js */ "./src/gl-matrix/vec4.js");\n\nvar vec4 = _interopRequireWildcard(_vec2);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * Quaternion\n * @module quat\n */\n\n/**\n * Creates a new identity quat\n *\n * @returns {quat} a new quaternion\n */\nfunction create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nfunction identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {vec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\nfunction setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as providied in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\n * @param  {quat} q     Quaternion to be decomposed\n * @return {Number}     Angle, in radians, of the rotation\n */\nfunction getAxisAngle(out_axis, q) {\n  var rad = Math.acos(q[3]) * 2.0;\n  var s = Math.sin(rad / 2.0);\n  if (s != 0.0) {\n    out_axis[0] = q[0] / s;\n    out_axis[1] = q[1] / s;\n    out_axis[2] = q[2] / s;\n  } else {\n    // If s is zero, return any axis (no rotation - axis does not matter)\n    out_axis[0] = 1;\n    out_axis[1] = 0;\n    out_axis[2] = 0;\n  }\n  return rad;\n}\n\n/**\n * Multiplies two quat\'s\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n */\nfunction multiply(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nfunction rotateX(out, a, rad) {\n  rad *= 0.5;\n\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = Math.sin(rad),\n      bw = Math.cos(rad);\n\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nfunction rotateY(out, a, rad) {\n  rad *= 0.5;\n\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var by = Math.sin(rad),\n      bw = Math.cos(rad);\n\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nfunction rotateZ(out, a, rad) {\n  rad *= 0.5;\n\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bz = Math.sin(rad),\n      bw = Math.cos(rad);\n\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate W component of\n * @returns {quat} out\n */\nfunction calculateW(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n  return out;\n}\n\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nfunction slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n\n  var omega = void 0,\n      cosom = void 0,\n      sinom = void 0,\n      scale0 = void 0,\n      scale1 = void 0;\n\n  // calc cosine\n  cosom = ax * bx + ay * by + az * bz + aw * bw;\n  // adjust signs (if necessary)\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  }\n  // calculate coefficients\n  if (1.0 - cosom > 0.000001) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // "from" and "to" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  }\n  // calculate final values\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n\n  return out;\n}\n\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate inverse of\n * @returns {quat} out\n */\nfunction invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n  var invDot = dot ? 1.0 / dot : 0;\n\n  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0 * invDot;\n  out[1] = -a1 * invDot;\n  out[2] = -a2 * invDot;\n  out[3] = a3 * invDot;\n  return out;\n}\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate conjugate of\n * @returns {quat} out\n */\nfunction conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {mat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\nfunction fromMat3(out, m) {\n  // Algorithm in Ken Shoemake\'s article in 1987 SIGGRAPH course notes\n  // article "Quaternion Calculus and Fast Animation".\n  var fTrace = m[0] + m[4] + m[8];\n  var fRoot = void 0;\n\n  if (fTrace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot; // 1/(4w)\n    out[0] = (m[5] - m[7]) * fRoot;\n    out[1] = (m[6] - m[2]) * fRoot;\n    out[2] = (m[1] - m[3]) * fRoot;\n  } else {\n    // |w| <= 1/2\n    var i = 0;\n    if (m[4] > m[0]) i = 1;\n    if (m[8] > m[i * 3 + i]) i = 2;\n    var j = (i + 1) % 3;\n    var k = (i + 2) % 3;\n\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n  }\n\n  return out;\n}\n\n/**\n * Creates a quaternion from the given euler angle x, y, z.\n *\n * @param {quat} out the receiving quaternion\n * @param {x} Angle to rotate around X axis in degrees.\n * @param {y} Angle to rotate around Y axis in degrees.\n * @param {z} Angle to rotate around Z axis in degrees.\n * @returns {quat} out\n * @function\n */\nfunction fromEuler(out, x, y, z) {\n  var halfToRad = 0.5 * Math.PI / 180.0;\n  x *= halfToRad;\n  y *= halfToRad;\n  z *= halfToRad;\n\n  var sx = Math.sin(x);\n  var cx = Math.cos(x);\n  var sy = Math.sin(y);\n  var cy = Math.cos(y);\n  var sz = Math.sin(z);\n  var cz = Math.cos(z);\n\n  out[0] = sx * cy * cz - cx * sy * sz;\n  out[1] = cx * sy * cz + sx * cy * sz;\n  out[2] = cx * cy * sz - sx * sy * cz;\n  out[3] = cx * cy * cz + sx * sy * sz;\n\n  return out;\n}\n\n/**\n * Returns a string representation of a quatenion\n *\n * @param {quat} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nfunction str(a) {\n  return \'quat(\' + a[0] + \', \' + a[1] + \', \' + a[2] + \', \' + a[3] + \')\';\n}\n\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {quat} a quaternion to clone\n * @returns {quat} a new quaternion\n * @function\n */\nvar clone = exports.clone = vec4.clone;\n\n/**\n * Creates a new quat initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} a new quaternion\n * @function\n */\nvar fromValues = exports.fromValues = vec4.fromValues;\n\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the source quaternion\n * @returns {quat} out\n * @function\n */\nvar copy = exports.copy = vec4.copy;\n\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\nvar set = exports.set = vec4.set;\n\n/**\n * Adds two quat\'s\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n * @function\n */\nvar add = exports.add = vec4.add;\n\n/**\n * Alias for {@link quat.multiply}\n * @function\n */\nvar mul = exports.mul = multiply;\n\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {quat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\nvar scale = exports.scale = vec4.scale;\n\n/**\n * Calculates the dot product of two quat\'s\n *\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\nvar dot = exports.dot = vec4.dot;\n\n/**\n * Performs a linear interpolation between two quat\'s\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n * @function\n */\nvar lerp = exports.lerp = vec4.lerp;\n\n/**\n * Calculates the length of a quat\n *\n * @param {quat} a vector to calculate length of\n * @returns {Number} length of a\n */\nvar length = exports.length = vec4.length;\n\n/**\n * Alias for {@link quat.length}\n * @function\n */\nvar len = exports.len = length;\n\n/**\n * Calculates the squared length of a quat\n *\n * @param {quat} a vector to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\nvar squaredLength = exports.squaredLength = vec4.squaredLength;\n\n/**\n * Alias for {@link quat.squaredLength}\n * @function\n */\nvar sqrLen = exports.sqrLen = squaredLength;\n\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\nvar normalize = exports.normalize = vec4.normalize;\n\n/**\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {quat} a The first quaternion.\n * @param {quat} b The second quaternion.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nvar exactEquals = exports.exactEquals = vec4.exactEquals;\n\n/**\n * Returns whether or not the quaternions have approximately the same elements in the same position.\n *\n * @param {quat} a The first vector.\n * @param {quat} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nvar equals = exports.equals = vec4.equals;\n\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {vec3} a the initial vector\n * @param {vec3} b the destination vector\n * @returns {quat} out\n */\nvar rotationTo = exports.rotationTo = function () {\n  var tmpvec3 = vec3.create();\n  var xUnitVec3 = vec3.fromValues(1, 0, 0);\n  var yUnitVec3 = vec3.fromValues(0, 1, 0);\n\n  return function (out, a, b) {\n    var dot = vec3.dot(a, b);\n    if (dot < -0.999999) {\n      vec3.cross(tmpvec3, xUnitVec3, a);\n      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);\n      vec3.normalize(tmpvec3, tmpvec3);\n      setAxisAngle(out, tmpvec3, Math.PI);\n      return out;\n    } else if (dot > 0.999999) {\n      out[0] = 0;\n      out[1] = 0;\n      out[2] = 0;\n      out[3] = 1;\n      return out;\n    } else {\n      vec3.cross(tmpvec3, a, b);\n      out[0] = tmpvec3[0];\n      out[1] = tmpvec3[1];\n      out[2] = tmpvec3[2];\n      out[3] = 1 + dot;\n      return normalize(out, out);\n    }\n  };\n}();\n\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {quat} c the third operand\n * @param {quat} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nvar sqlerp = exports.sqlerp = function () {\n  var temp1 = create();\n  var temp2 = create();\n\n  return function (out, a, b, c, d, t) {\n    slerp(temp1, a, d, t);\n    slerp(temp2, b, c, t);\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\n\n    return out;\n  };\n}();\n\n/**\n * Sets the specified quaternion with values corresponding to the given\n * axes. Each axis is a vec3 and is expected to be unit length and\n * perpendicular to all other specified axes.\n *\n * @param {vec3} view  the vector representing the viewing direction\n * @param {vec3} right the vector representing the local "right" direction\n * @param {vec3} up    the vector representing the local "up" direction\n * @returns {quat} out\n */\nvar setAxes = exports.setAxes = function () {\n  var matr = mat3.create();\n\n  return function (out, view, right, up) {\n    matr[0] = right[0];\n    matr[3] = right[1];\n    matr[6] = right[2];\n\n    matr[1] = up[0];\n    matr[4] = up[1];\n    matr[7] = up[2];\n\n    matr[2] = -view[0];\n    matr[5] = -view[1];\n    matr[8] = -view[2];\n\n    return normalize(out, fromMat3(out, matr));\n  };\n}();\n\n//# sourceURL=webpack:///./src/gl-matrix/quat.js?')},"./src/gl-matrix/quat2.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sqrLen = exports.squaredLength = exports.len = exports.length = exports.dot = exports.mul = exports.setReal = exports.getReal = undefined;\nexports.create = create;\nexports.clone = clone;\nexports.fromValues = fromValues;\nexports.fromRotationTranslationValues = fromRotationTranslationValues;\nexports.fromRotationTranslation = fromRotationTranslation;\nexports.fromTranslation = fromTranslation;\nexports.fromRotation = fromRotation;\nexports.fromMat4 = fromMat4;\nexports.copy = copy;\nexports.identity = identity;\nexports.set = set;\nexports.getDual = getDual;\nexports.setDual = setDual;\nexports.getTranslation = getTranslation;\nexports.translate = translate;\nexports.rotateX = rotateX;\nexports.rotateY = rotateY;\nexports.rotateZ = rotateZ;\nexports.rotateByQuatAppend = rotateByQuatAppend;\nexports.rotateByQuatPrepend = rotateByQuatPrepend;\nexports.rotateAroundAxis = rotateAroundAxis;\nexports.add = add;\nexports.multiply = multiply;\nexports.scale = scale;\nexports.lerp = lerp;\nexports.invert = invert;\nexports.conjugate = conjugate;\nexports.normalize = normalize;\nexports.str = str;\nexports.exactEquals = exactEquals;\nexports.equals = equals;\n\nvar _common = __webpack_require__(/*! ./common.js */ \"./src/gl-matrix/common.js\");\n\nvar glMatrix = _interopRequireWildcard(_common);\n\nvar _quat = __webpack_require__(/*! ./quat.js */ \"./src/gl-matrix/quat.js\");\n\nvar quat = _interopRequireWildcard(_quat);\n\nvar _mat = __webpack_require__(/*! ./mat4.js */ \"./src/gl-matrix/mat4.js\");\n\nvar mat4 = _interopRequireWildcard(_mat);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * Dual Quaternion<br>\n * Format: [real, dual]<br>\n * Quaternion format: XYZW<br>\n * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>\n * @module quat2\n */\n\n/**\n * Creates a new identity dual quat\n *\n * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]\n */\nfunction create() {\n  var dq = new glMatrix.ARRAY_TYPE(8);\n  dq[0] = 0;\n  dq[1] = 0;\n  dq[2] = 0;\n  dq[3] = 1;\n  dq[4] = 0;\n  dq[5] = 0;\n  dq[6] = 0;\n  dq[7] = 0;\n  return dq;\n}\n\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {quat2} a dual quaternion to clone\n * @returns {quat2} new dual quaternion\n * @function\n */\nfunction clone(a) {\n  var dq = new glMatrix.ARRAY_TYPE(8);\n  dq[0] = a[0];\n  dq[1] = a[1];\n  dq[2] = a[2];\n  dq[3] = a[3];\n  dq[4] = a[4];\n  dq[5] = a[5];\n  dq[6] = a[6];\n  dq[7] = a[7];\n  return dq;\n}\n\n/**\n * Creates a new dual quat initialized with the given values\n *\n * @param {Number} x1 X component\n * @param {Number} y1 Y component\n * @param {Number} z1 Z component\n * @param {Number} w1 W component\n * @param {Number} x2 X component\n * @param {Number} y2 Y component\n * @param {Number} z2 Z component\n * @param {Number} w2 W component\n * @returns {quat2} new dual quaternion\n * @function\n */\nfunction fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {\n  var dq = new glMatrix.ARRAY_TYPE(8);\n  dq[0] = x1;\n  dq[1] = y1;\n  dq[2] = z1;\n  dq[3] = w1;\n  dq[4] = x2;\n  dq[5] = y2;\n  dq[6] = z2;\n  dq[7] = w2;\n  return dq;\n}\n\n/**\n * Creates a new dual quat from the given values (quat and translation)\n *\n * @param {Number} x1 X component\n * @param {Number} y1 Y component\n * @param {Number} z1 Z component\n * @param {Number} w1 W component\n * @param {Number} x2 X component (translation)\n * @param {Number} y2 Y component (translation)\n * @param {Number} z2 Z component (translation)\n * @returns {quat2} new dual quaternion\n * @function\n */\nfunction fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {\n  var dq = new glMatrix.ARRAY_TYPE(8);\n  dq[0] = x1;\n  dq[1] = y1;\n  dq[2] = z1;\n  dq[3] = w1;\n  var ax = x2 * 0.5,\n      ay = y2 * 0.5,\n      az = z2 * 0.5;\n  dq[4] = ax * w1 + ay * z1 - az * y1;\n  dq[5] = ay * w1 + az * x1 - ax * z1;\n  dq[6] = az * w1 + ax * y1 - ay * x1;\n  dq[7] = -ax * x1 - ay * y1 - az * z1;\n  return dq;\n}\n\n/**\n * Creates a dual quat from a quaternion and a translation\n *\n * @param {quat2} dual quaternion receiving operation result\n * @param {quat} q quaternion\n * @param {vec3} t tranlation vector\n * @returns {quat2} dual quaternion receiving operation result\n * @function\n */\nfunction fromRotationTranslation(out, q, t) {\n  var ax = t[0] * 0.5,\n      ay = t[1] * 0.5,\n      az = t[2] * 0.5,\n      bx = q[0],\n      by = q[1],\n      bz = q[2],\n      bw = q[3];\n  out[0] = bx;\n  out[1] = by;\n  out[2] = bz;\n  out[3] = bw;\n  out[4] = ax * bw + ay * bz - az * by;\n  out[5] = ay * bw + az * bx - ax * bz;\n  out[6] = az * bw + ax * by - ay * bx;\n  out[7] = -ax * bx - ay * by - az * bz;\n  return out;\n}\n\n/**\n * Creates a dual quat from a translation\n *\n * @param {quat2} dual quaternion receiving operation result\n * @param {vec3} t translation vector\n * @returns {quat2} dual quaternion receiving operation result\n * @function\n */\nfunction fromTranslation(out, t) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = t[0] * 0.5;\n  out[5] = t[1] * 0.5;\n  out[6] = t[2] * 0.5;\n  out[7] = 0;\n  return out;\n}\n\n/**\n * Creates a dual quat from a quaternion\n *\n * @param {quat2} dual quaternion receiving operation result\n * @param {quat} q the quaternion\n * @returns {quat2} dual quaternion receiving operation result\n * @function\n */\nfunction fromRotation(out, q) {\n  out[0] = q[0];\n  out[1] = q[1];\n  out[2] = q[2];\n  out[3] = q[3];\n  out[4] = 0;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  return out;\n}\n\n/**\n * Creates a new dual quat from a matrix (4x4)\n *\n * @param {quat2} out the dual quaternion\n * @param {mat4} a the matrix\n * @returns {quat2} dual quat receiving operation result\n * @function\n */\nfunction fromMat4(out, a) {\n  //TODO Optimize this\n  var outer = quat.create();\n  mat4.getRotation(outer, a);\n  var t = new glMatrix.ARRAY_TYPE(3);\n  mat4.getTranslation(t, a);\n  fromRotationTranslation(out, outer, t);\n  return out;\n}\n\n/**\n * Copy the values from one dual quat to another\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the source dual quaternion\n * @returns {quat2} out\n * @function\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  return out;\n}\n\n/**\n * Set a dual quat to the identity dual quaternion\n *\n * @param {quat2} out the receiving quaternion\n * @returns {quat2} out\n */\nfunction identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  return out;\n}\n\n/**\n * Set the components of a dual quat to the given values\n *\n * @param {quat2} out the receiving quaternion\n * @param {Number} x1 X component\n * @param {Number} y1 Y component\n * @param {Number} z1 Z component\n * @param {Number} w1 W component\n * @param {Number} x2 X component\n * @param {Number} y2 Y component\n * @param {Number} z2 Z component\n * @param {Number} w2 W component\n * @returns {quat2} out\n * @function\n */\nfunction set(out, x1, y1, z1, w1, x2, y2, z2, w2) {\n  out[0] = x1;\n  out[1] = y1;\n  out[2] = z1;\n  out[3] = w1;\n\n  out[4] = x2;\n  out[5] = y2;\n  out[6] = z2;\n  out[7] = w2;\n  return out;\n}\n\n/**\n * Gets the real part of a dual quat\n * @param  {quat} out real part\n * @param  {quat2} a Dual Quaternion\n * @return {quat} real part\n */\nvar getReal = exports.getReal = quat.copy;\n\n/**\n * Gets the dual part of a dual quat\n * @param  {quat} out dual part\n * @param  {quat2} a Dual Quaternion\n * @return {quat} dual part\n */\nfunction getDual(out, a) {\n  out[0] = a[4];\n  out[1] = a[5];\n  out[2] = a[6];\n  out[3] = a[7];\n  return out;\n}\n\n/**\n * Set the real component of a dual quat to the given quaternion\n *\n * @param {quat2} out the receiving quaternion\n * @param {quat} q a quaternion representing the real part\n * @returns {quat2} out\n * @function\n */\nvar setReal = exports.setReal = quat.copy;\n\n/**\n * Set the dual component of a dual quat to the given quaternion\n *\n * @param {quat2} out the receiving quaternion\n * @param {quat} q a quaternion representing the dual part\n * @returns {quat2} out\n * @function\n */\nfunction setDual(out, q) {\n  out[4] = q[0];\n  out[5] = q[1];\n  out[6] = q[2];\n  out[7] = q[3];\n  return out;\n}\n\n/**\n * Gets the translation of a normalized dual quat\n * @param  {vec3} out translation\n * @param  {quat2} a Dual Quaternion to be decomposed\n * @return {vec3} translation\n */\nfunction getTranslation(out, a) {\n  var ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3];\n  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  return out;\n}\n\n/**\n * Translates a dual quat by the given vector\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the dual quaternion to translate\n * @param {vec3} v vector to translate by\n * @returns {quat2} out\n */\nfunction translate(out, a, v) {\n  var ax1 = a[0],\n      ay1 = a[1],\n      az1 = a[2],\n      aw1 = a[3],\n      bx1 = v[0] * 0.5,\n      by1 = v[1] * 0.5,\n      bz1 = v[2] * 0.5,\n      ax2 = a[4],\n      ay2 = a[5],\n      az2 = a[6],\n      aw2 = a[7];\n  out[0] = ax1;\n  out[1] = ay1;\n  out[2] = az1;\n  out[3] = aw1;\n  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;\n  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;\n  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;\n  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;\n  return out;\n}\n\n/**\n * Rotates a dual quat around the X axis\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the dual quaternion to rotate\n * @param {number} rad how far should the rotation be\n * @returns {quat2} out\n */\nfunction rotateX(out, a, rad) {\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  quat.rotateX(out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n\n/**\n * Rotates a dual quat around the Y axis\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the dual quaternion to rotate\n * @param {number} rad how far should the rotation be\n * @returns {quat2} out\n */\nfunction rotateY(out, a, rad) {\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  quat.rotateY(out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n\n/**\n * Rotates a dual quat around the Z axis\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the dual quaternion to rotate\n * @param {number} rad how far should the rotation be\n * @returns {quat2} out\n */\nfunction rotateZ(out, a, rad) {\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  quat.rotateZ(out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n\n/**\n * Rotates a dual quat by a given quaternion (a * q)\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the dual quaternion to rotate\n * @param {quat} q quaternion to rotate by\n * @returns {quat2} out\n */\nfunction rotateByQuatAppend(out, a, q) {\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3],\n      ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n\n  out[0] = ax * qw + aw * qx + ay * qz - az * qy;\n  out[1] = ay * qw + aw * qy + az * qx - ax * qz;\n  out[2] = az * qw + aw * qz + ax * qy - ay * qx;\n  out[3] = aw * qw - ax * qx - ay * qy - az * qz;\n  ax = a[4];\n  ay = a[5];\n  az = a[6];\n  aw = a[7];\n  out[4] = ax * qw + aw * qx + ay * qz - az * qy;\n  out[5] = ay * qw + aw * qy + az * qx - ax * qz;\n  out[6] = az * qw + aw * qz + ax * qy - ay * qx;\n  out[7] = aw * qw - ax * qx - ay * qy - az * qz;\n  return out;\n}\n\n/**\n * Rotates a dual quat by a given quaternion (q * a)\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat} q quaternion to rotate by\n * @param {quat2} a the dual quaternion to rotate\n * @returns {quat2} out\n */\nfunction rotateByQuatPrepend(out, q, a) {\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3],\n      bx = a[0],\n      by = a[1],\n      bz = a[2],\n      bw = a[3];\n\n  out[0] = qx * bw + qw * bx + qy * bz - qz * by;\n  out[1] = qy * bw + qw * by + qz * bx - qx * bz;\n  out[2] = qz * bw + qw * bz + qx * by - qy * bx;\n  out[3] = qw * bw - qx * bx - qy * by - qz * bz;\n  bx = a[4];\n  by = a[5];\n  bz = a[6];\n  bw = a[7];\n  out[4] = qx * bw + qw * bx + qy * bz - qz * by;\n  out[5] = qy * bw + qw * by + qz * bx - qx * bz;\n  out[6] = qz * bw + qw * bz + qx * by - qy * bx;\n  out[7] = qw * bw - qx * bx - qy * by - qz * bz;\n  return out;\n}\n\n/**\n * Rotates a dual quat around a given axis. Does the normalisation automatically\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the dual quaternion to rotate\n * @param {vec3} axis the axis to rotate around\n * @param {Number} rad how far the rotation should be\n * @returns {quat2} out\n */\nfunction rotateAroundAxis(out, a, axis, rad) {\n  //Special case for rad = 0\n  if (Math.abs(rad) < glMatrix.EPSILON) {\n    return copy(out, a);\n  }\n  var axisLength = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);\n\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  var bx = s * axis[0] / axisLength;\n  var by = s * axis[1] / axisLength;\n  var bz = s * axis[2] / axisLength;\n  var bw = Math.cos(rad);\n\n  var ax1 = a[0],\n      ay1 = a[1],\n      az1 = a[2],\n      aw1 = a[3];\n  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n\n  var ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  out[4] = ax * bw + aw * bx + ay * bz - az * by;\n  out[5] = ay * bw + aw * by + az * bx - ax * bz;\n  out[6] = az * bw + aw * bz + ax * by - ay * bx;\n  out[7] = aw * bw - ax * bx - ay * by - az * bz;\n\n  return out;\n}\n\n/**\n * Adds two dual quat's\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the first operand\n * @param {quat2} b the second operand\n * @returns {quat2} out\n * @function\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  return out;\n}\n\n/**\n * Multiplies two dual quat's\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the first operand\n * @param {quat2} b the second operand\n * @returns {quat2} out\n */\nfunction multiply(out, a, b) {\n  var ax0 = a[0],\n      ay0 = a[1],\n      az0 = a[2],\n      aw0 = a[3],\n      bx1 = b[4],\n      by1 = b[5],\n      bz1 = b[6],\n      bw1 = b[7],\n      ax1 = a[4],\n      ay1 = a[5],\n      az1 = a[6],\n      aw1 = a[7],\n      bx0 = b[0],\n      by0 = b[1],\n      bz0 = b[2],\n      bw0 = b[3];\n  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;\n  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;\n  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;\n  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;\n  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;\n  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;\n  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;\n  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;\n  return out;\n}\n\n/**\n * Alias for {@link quat2.multiply}\n * @function\n */\nvar mul = exports.mul = multiply;\n\n/**\n * Scales a dual quat by a scalar number\n *\n * @param {quat2} out the receiving dual quat\n * @param {quat2} a the dual quat to scale\n * @param {Number} b amount to scale the dual quat by\n * @returns {quat2} out\n * @function\n */\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  return out;\n}\n\n/**\n * Calculates the dot product of two dual quat's (The dot product of the real parts)\n *\n * @param {quat2} a the first operand\n * @param {quat2} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\nvar dot = exports.dot = quat.dot;\n\n/**\n * Performs a linear interpolation between two dual quats's\n * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)\n *\n * @param {quat2} out the receiving dual quat\n * @param {quat2} a the first operand\n * @param {quat2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat2} out\n */\nfunction lerp(out, a, b, t) {\n  var mt = 1 - t;\n  if (dot(a, b) < 0) t = -t;\n\n  out[0] = a[0] * mt + b[0] * t;\n  out[1] = a[1] * mt + b[1] * t;\n  out[2] = a[2] * mt + b[2] * t;\n  out[3] = a[3] * mt + b[3] * t;\n  out[4] = a[4] * mt + b[4] * t;\n  out[5] = a[5] * mt + b[5] * t;\n  out[6] = a[6] * mt + b[6] * t;\n  out[7] = a[7] * mt + b[7] * t;\n\n  return out;\n}\n\n/**\n * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a dual quat to calculate inverse of\n * @returns {quat2} out\n */\nfunction invert(out, a) {\n  var sqlen = squaredLength(a);\n  out[0] = -a[0] / sqlen;\n  out[1] = -a[1] / sqlen;\n  out[2] = -a[2] / sqlen;\n  out[3] = a[3] / sqlen;\n  out[4] = -a[4] / sqlen;\n  out[5] = -a[5] / sqlen;\n  out[6] = -a[6] / sqlen;\n  out[7] = a[7] / sqlen;\n  return out;\n}\n\n/**\n * Calculates the conjugate of a dual quat\n * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.\n *\n * @param {quat2} out the receiving quaternion\n * @param {quat2} a quat to calculate conjugate of\n * @returns {quat2} out\n */\nfunction conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  out[4] = -a[4];\n  out[5] = -a[5];\n  out[6] = -a[6];\n  out[7] = a[7];\n  return out;\n}\n\n/**\n * Calculates the length of a dual quat\n *\n * @param {quat2} a dual quat to calculate length of\n * @returns {Number} length of a\n * @function\n */\nvar length = exports.length = quat.length;\n\n/**\n * Alias for {@link quat2.length}\n * @function\n */\nvar len = exports.len = length;\n\n/**\n * Calculates the squared length of a dual quat\n *\n * @param {quat2} a dual quat to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\nvar squaredLength = exports.squaredLength = quat.squaredLength;\n\n/**\n * Alias for {@link quat2.squaredLength}\n * @function\n */\nvar sqrLen = exports.sqrLen = squaredLength;\n\n/**\n * Normalize a dual quat\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a dual quaternion to normalize\n * @returns {quat2} out\n * @function\n */\nfunction normalize(out, a) {\n  var magnitude = squaredLength(a);\n  if (magnitude > 0) {\n    magnitude = Math.sqrt(magnitude);\n    out[0] = a[0] / magnitude;\n    out[1] = a[1] / magnitude;\n    out[2] = a[2] / magnitude;\n    out[3] = a[3] / magnitude;\n    out[4] = a[4] / magnitude;\n    out[5] = a[5] / magnitude;\n    out[6] = a[6] / magnitude;\n    out[7] = a[7] / magnitude;\n  }\n  return out;\n}\n\n/**\n * Returns a string representation of a dual quatenion\n *\n * @param {quat2} a dual quaternion to represent as a string\n * @returns {String} string representation of the dual quat\n */\nfunction str(a) {\n  return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';\n}\n\n/**\n * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {quat2} a the first dual quaternion.\n * @param {quat2} b the second dual quaternion.\n * @returns {Boolean} true if the dual quaternions are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];\n}\n\n/**\n * Returns whether or not the dual quaternions have approximately the same elements in the same position.\n *\n * @param {quat2} a the first dual quat.\n * @param {quat2} b the second dual quat.\n * @returns {Boolean} true if the dual quats are equal, false otherwise.\n */\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));\n}\n\n//# sourceURL=webpack:///./src/gl-matrix/quat2.js?")},"./src/gl-matrix/vec2.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forEach = exports.sqrLen = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = exports.len = undefined;\nexports.create = create;\nexports.clone = clone;\nexports.fromValues = fromValues;\nexports.copy = copy;\nexports.set = set;\nexports.add = add;\nexports.subtract = subtract;\nexports.multiply = multiply;\nexports.divide = divide;\nexports.ceil = ceil;\nexports.floor = floor;\nexports.min = min;\nexports.max = max;\nexports.round = round;\nexports.scale = scale;\nexports.scaleAndAdd = scaleAndAdd;\nexports.distance = distance;\nexports.squaredDistance = squaredDistance;\nexports.length = length;\nexports.squaredLength = squaredLength;\nexports.negate = negate;\nexports.inverse = inverse;\nexports.normalize = normalize;\nexports.dot = dot;\nexports.cross = cross;\nexports.lerp = lerp;\nexports.random = random;\nexports.transformMat2 = transformMat2;\nexports.transformMat2d = transformMat2d;\nexports.transformMat3 = transformMat3;\nexports.transformMat4 = transformMat4;\nexports.rotate = rotate;\nexports.angle = angle;\nexports.str = str;\nexports.exactEquals = exactEquals;\nexports.equals = equals;\n\nvar _common = __webpack_require__(/*! ./common.js */ \"./src/gl-matrix/common.js\");\n\nvar glMatrix = _interopRequireWildcard(_common);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * 2 Dimensional Vector\n * @module vec2\n */\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\nfunction create() {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = 0;\n  out[1] = 0;\n  return out;\n}\n\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {vec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\nfunction fromValues(x, y) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the source vector\n * @returns {vec2} out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\nfunction set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to ceil\n * @returns {vec2} out\n */\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to floor\n * @returns {vec2} out\n */\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n\n/**\n * Math.round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to round\n * @returns {vec2} out\n */\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} distance between a and b\n */\nfunction distance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return x * x + y * y;\n}\n\n/**\n * Calculates the length of a vec2\n *\n * @param {vec2} a vector to calculate length of\n * @returns {Number} length of a\n */\nfunction length(a) {\n  var x = a[0],\n      y = a[1];\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\n * Calculates the squared length of a vec2\n *\n * @param {vec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nfunction squaredLength(a) {\n  var x = a[0],\n      y = a[1];\n  return x * x + y * y;\n}\n\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to negate\n * @returns {vec2} out\n */\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to invert\n * @returns {vec2} out\n */\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to normalize\n * @returns {vec2} out\n */\nfunction normalize(out, a) {\n  var x = a[0],\n      y = a[1];\n  var len = x * x + y * y;\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n    out[0] = a[0] * len;\n    out[1] = a[1] * len;\n  }\n  return out;\n}\n\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} dot product of a and b\n */\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec3} out\n */\nfunction cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec2} out\n */\nfunction lerp(out, a, b, t) {\n  var ax = a[0],\n      ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec2} out\n */\nfunction random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2} m matrix to transform with\n * @returns {vec2} out\n */\nfunction transformMat2(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2d} m matrix to transform with\n * @returns {vec2} out\n */\nfunction transformMat2d(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat3} m matrix to transform with\n * @returns {vec2} out\n */\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec2} out\n */\nfunction transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n\n/**\n * Rotate a 2D vector\n * @param {vec2} out The receiving vec2\n * @param {vec2} a The vec2 point to rotate\n * @param {vec2} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec2} out\n */\nfunction rotate(out, a, b, c) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n      p1 = a[1] - b[1],\n      sinC = Math.sin(c),\n      cosC = Math.cos(c);\n\n  //perform rotation and translate to correct position\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n\n  return out;\n}\n\n/**\n * Get the angle between two 2D vectors\n * @param {vec2} a The first operand\n * @param {vec2} b The second operand\n * @returns {Number} The angle in radians\n */\nfunction angle(a, b) {\n  var x1 = a[0],\n      y1 = a[1],\n      x2 = b[0],\n      y2 = b[1];\n\n  var len1 = x1 * x1 + y1 * y1;\n  if (len1 > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len1 = 1 / Math.sqrt(len1);\n  }\n\n  var len2 = x2 * x2 + y2 * y2;\n  if (len2 > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len2 = 1 / Math.sqrt(len2);\n  }\n\n  var cosine = (x1 * x2 + y1 * y2) * len1 * len2;\n\n  if (cosine > 1.0) {\n    return 0;\n  } else if (cosine < -1.0) {\n    return Math.PI;\n  } else {\n    return Math.acos(cosine);\n  }\n}\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec2} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nfunction str(a) {\n  return 'vec2(' + a[0] + ', ' + a[1] + ')';\n}\n\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {vec2} a The first vector.\n * @param {vec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec2} a The first vector.\n * @param {vec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1];\n  var b0 = b[0],\n      b1 = b[1];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n\n/**\n * Alias for {@link vec2.length}\n * @function\n */\nvar len = exports.len = length;\n\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\nvar sub = exports.sub = subtract;\n\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\nvar mul = exports.mul = multiply;\n\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\nvar div = exports.div = divide;\n\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\nvar dist = exports.dist = distance;\n\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\nvar sqrDist = exports.sqrDist = squaredDistance;\n\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\nvar sqrLen = exports.sqrLen = squaredLength;\n\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nvar forEach = exports.forEach = function () {\n  var vec = create();\n\n  return function (a, stride, offset, count, fn, arg) {\n    var i = void 0,\n        l = void 0;\n    if (!stride) {\n      stride = 2;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];a[i + 1] = vec[1];\n    }\n\n    return a;\n  };\n}();\n\n//# sourceURL=webpack:///./src/gl-matrix/vec2.js?")},"./src/gl-matrix/vec3.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = undefined;\nexports.create = create;\nexports.clone = clone;\nexports.length = length;\nexports.fromValues = fromValues;\nexports.copy = copy;\nexports.set = set;\nexports.add = add;\nexports.subtract = subtract;\nexports.multiply = multiply;\nexports.divide = divide;\nexports.ceil = ceil;\nexports.floor = floor;\nexports.min = min;\nexports.max = max;\nexports.round = round;\nexports.scale = scale;\nexports.scaleAndAdd = scaleAndAdd;\nexports.distance = distance;\nexports.squaredDistance = squaredDistance;\nexports.squaredLength = squaredLength;\nexports.negate = negate;\nexports.inverse = inverse;\nexports.normalize = normalize;\nexports.dot = dot;\nexports.cross = cross;\nexports.lerp = lerp;\nexports.hermite = hermite;\nexports.bezier = bezier;\nexports.random = random;\nexports.transformMat4 = transformMat4;\nexports.transformMat3 = transformMat3;\nexports.transformQuat = transformQuat;\nexports.rotateX = rotateX;\nexports.rotateY = rotateY;\nexports.rotateZ = rotateZ;\nexports.angle = angle;\nexports.str = str;\nexports.exactEquals = exactEquals;\nexports.equals = equals;\n\nvar _common = __webpack_require__(/*! ./common.js */ \"./src/gl-matrix/common.js\");\n\nvar glMatrix = _interopRequireWildcard(_common);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\nfunction create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  return out;\n}\n\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {vec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n\n/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */\nfunction length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.sqrt(x * x + y * y + z * z);\n}\n\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\nfunction fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nfunction set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to ceil\n * @returns {vec3} out\n */\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to floor\n * @returns {vec3} out\n */\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to round\n * @returns {vec3} out\n */\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */\nfunction distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.sqrt(x * x + y * y + z * z);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nfunction squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to invert\n * @returns {vec3} out\n */\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\nfunction normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n    out[0] = a[0] * len;\n    out[1] = a[1] * len;\n    out[2] = a[2] * len;\n  }\n  return out;\n}\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\nfunction lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {vec3} c the third operand\n * @param {vec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\nfunction hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n\n  return out;\n}\n\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {vec3} c the third operand\n * @param {vec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\nfunction bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n\n  return out;\n}\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\nfunction random(out, scale) {\n  scale = scale || 1.0;\n\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec3} out\n */\nfunction transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x;\n  // var uuv = vec3.cross([], qvec, uv);\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx;\n  // vec3.scale(uv, uv, 2 * w);\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2;\n  // vec3.scale(uuv, uuv, 2);\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2;\n  // return vec3.add(out, a, vec3.add(out, uv, uuv));\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateX(out, a, b, c) {\n  var p = [],\n      r = [];\n  //Translate point to the origin\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2];\n\n  //perform rotation\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);\n  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);\n\n  //translate to correct position\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n\n  return out;\n}\n\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateY(out, a, b, c) {\n  var p = [],\n      r = [];\n  //Translate point to the origin\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2];\n\n  //perform rotation\n  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);\n\n  //translate to correct position\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n\n  return out;\n}\n\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateZ(out, a, b, c) {\n  var p = [],\n      r = [];\n  //Translate point to the origin\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2];\n\n  //perform rotation\n  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);\n  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);\n  r[2] = p[2];\n\n  //translate to correct position\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n\n  return out;\n}\n\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */\nfunction angle(a, b) {\n  var tempA = fromValues(a[0], a[1], a[2]);\n  var tempB = fromValues(b[0], b[1], b[2]);\n\n  normalize(tempA, tempA);\n  normalize(tempB, tempB);\n\n  var cosine = dot(tempA, tempB);\n\n  if (cosine > 1.0) {\n    return 0;\n  } else if (cosine < -1.0) {\n    return Math.PI;\n  } else {\n    return Math.acos(cosine);\n  }\n}\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nfunction str(a) {\n  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';\n}\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\nvar sub = exports.sub = subtract;\n\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\nvar mul = exports.mul = multiply;\n\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\nvar div = exports.div = divide;\n\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\nvar dist = exports.dist = distance;\n\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\nvar sqrDist = exports.sqrDist = squaredDistance;\n\n/**\n * Alias for {@link vec3.length}\n * @function\n */\nvar len = exports.len = length;\n\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\nvar sqrLen = exports.sqrLen = squaredLength;\n\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nvar forEach = exports.forEach = function () {\n  var vec = create();\n\n  return function (a, stride, offset, count, fn, arg) {\n    var i = void 0,\n        l = void 0;\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();\n\n//# sourceURL=webpack:///./src/gl-matrix/vec3.js?")},"./src/gl-matrix/vec4.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = undefined;\nexports.create = create;\nexports.clone = clone;\nexports.fromValues = fromValues;\nexports.copy = copy;\nexports.set = set;\nexports.add = add;\nexports.subtract = subtract;\nexports.multiply = multiply;\nexports.divide = divide;\nexports.ceil = ceil;\nexports.floor = floor;\nexports.min = min;\nexports.max = max;\nexports.round = round;\nexports.scale = scale;\nexports.scaleAndAdd = scaleAndAdd;\nexports.distance = distance;\nexports.squaredDistance = squaredDistance;\nexports.length = length;\nexports.squaredLength = squaredLength;\nexports.negate = negate;\nexports.inverse = inverse;\nexports.normalize = normalize;\nexports.dot = dot;\nexports.lerp = lerp;\nexports.random = random;\nexports.transformMat4 = transformMat4;\nexports.transformQuat = transformQuat;\nexports.str = str;\nexports.exactEquals = exactEquals;\nexports.equals = equals;\n\nvar _common = __webpack_require__(/*! ./common.js */ \"./src/gl-matrix/common.js\");\n\nvar glMatrix = _interopRequireWildcard(_common);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * 4 Dimensional Vector\n * @module vec4\n */\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\nfunction create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  return out;\n}\n\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {vec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\nfunction fromValues(x, y, z, w) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the source vector\n * @returns {vec4} out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\nfunction set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n\n/**\n * Math.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to ceil\n * @returns {vec4} out\n */\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n\n/**\n * Math.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to floor\n * @returns {vec4} out\n */\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n\n/**\n * Math.round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to round\n * @returns {vec4} out\n */\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} distance between a and b\n */\nfunction distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.sqrt(x * x + y * y + z * z + w * w);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n\n/**\n * Calculates the length of a vec4\n *\n * @param {vec4} a vector to calculate length of\n * @returns {Number} length of a\n */\nfunction length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.sqrt(x * x + y * y + z * z + w * w);\n}\n\n/**\n * Calculates the squared length of a vec4\n *\n * @param {vec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nfunction squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to negate\n * @returns {vec4} out\n */\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to invert\n * @returns {vec4} out\n */\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to normalize\n * @returns {vec4} out\n */\nfunction normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    out[0] = x * len;\n    out[1] = y * len;\n    out[2] = z * len;\n    out[3] = w * len;\n  }\n  return out;\n}\n\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} dot product of a and b\n */\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec4} out\n */\nfunction lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec4} out\n */\nfunction random(out, vectorScale) {\n  vectorScale = vectorScale || 1.0;\n\n  // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n  var v1, v2, v3, v4;\n  var s1, s2;\n  do {\n    v1 = glMatrix.RANDOM() * 2 - 1;\n    v2 = glMatrix.RANDOM() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n  do {\n    v3 = glMatrix.RANDOM() * 2 - 1;\n    v4 = glMatrix.RANDOM() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec4} out\n */\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec4} out\n */\nfunction transformQuat(out, a, q) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n\n  // calculate quat * vec\n  var ix = qw * x + qy * z - qz * y;\n  var iy = qw * y + qz * x - qx * z;\n  var iz = qw * z + qx * y - qy * x;\n  var iw = -qx * x - qy * y - qz * z;\n\n  // calculate result * inverse quat\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec4} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nfunction str(a) {\n  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n}\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {vec4} a The first vector.\n * @param {vec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec4} a The first vector.\n * @param {vec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\nvar sub = exports.sub = subtract;\n\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\nvar mul = exports.mul = multiply;\n\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\nvar div = exports.div = divide;\n\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\nvar dist = exports.dist = distance;\n\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\nvar sqrDist = exports.sqrDist = squaredDistance;\n\n/**\n * Alias for {@link vec4.length}\n * @function\n */\nvar len = exports.len = length;\n\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\nvar sqrLen = exports.sqrLen = squaredLength;\n\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nvar forEach = exports.forEach = function () {\n  var vec = create();\n\n  return function (a, stride, offset, count, fn, arg) {\n    var i = void 0,\n        l = void 0;\n    if (!stride) {\n      stride = 4;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];a[i + 3] = vec[3];\n    }\n\n    return a;\n  };\n}();\n\n//# sourceURL=webpack:///./src/gl-matrix/vec4.js?")}})})},{}]},{},["C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\main.js"])("C:\\Users\\10zil\\OneDrive\\Documents\\Visual Studio 2017\\Projects\\Web\\WebGL BSP\\.tmp\\main.js")});
//# sourceMappingURL=WebBSP.js.map
